
// This file was automatically @generated by `isa`. Regenerate e.g. by:
// cd isa && cargo run -- md_to_rs ../doc ../server/src/generated.rs

pub static HOVERS: phf::Map<&'static str, &'static str> = ::phf::Map {
    key: 12913932095322966823,
    disps: &[
        (1, 0),
        (0, 9),
        (0, 30),
        (0, 5),
        (0, 327),
        (0, 182),
        (0, 14),
        (0, 93),
        (0, 0),
        (0, 15),
        (4, 221),
        (3, 69),
        (0, 56),
        (0, 2),
        (1, 186),
        (13, 255),
        (1, 218),
        (0, 1),
        (0, 119),
        (0, 14),
        (1, 4),
        (5, 155),
        (0, 162),
        (0, 8),
        (6, 257),
        (0, 3),
        (0, 3),
        (0, 27),
        (0, 147),
        (0, 17),
        (42, 208),
        (2, 326),
        (4, 189),
        (1, 124),
        (0, 0),
        (0, 132),
        (0, 55),
        (28, 177),
        (0, 83),
        (35, 297),
        (0, 95),
        (0, 109),
        (0, 213),
        (1, 21),
        (0, 134),
        (4, 171),
        (36, 160),
        (0, 33),
        (0, 0),
        (4, 183),
        (0, 0),
        (0, 88),
        (0, 4),
        (0, 0),
        (0, 6),
        (13, 118),
        (14, 274),
        (1, 56),
        (65, 272),
        (0, 7),
        (14, 301),
        (0, 0),
        (0, 4),
        (4, 32),
        (11, 100),
        (0, 20),
    ],
    entries: &[
        ("$SNOTIFY", "Software notification register. Each implemented field controls an\nexternal implementation specific hardware feature.\n"),
        ("st32step", "* `st32step $mSrc0, $mBase0, $mDelta0+=, simm8`\n* `st32step $aSrc0, $mBase0, $mDelta0+=, simm8`\n* `st32step $aSrc0, $mBase0, $mDelta0+=, $mStride0`\n\nNaturally aligned 32-bit store with scaled post-incrementing address.\n\nSource register-file: MRF or ARF\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("f32div", "* `f32div $aDst0, $aSrc0, $aSrc1`\n\nFloating-point division of two register source values.\n"),
        ("$m8", "`$m8` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("nop", "Do nothing for one cycle (main pipeline). Alias for `or $mzero, $mzero, 0`\n"),
        ("f16v2tof32", "* `f16v2tof32 $aDst0:Dst0+1, $aSrc0`\n\n*f16* floating-point pair to *single-precision* conversion\n"),
        ("$INCOMING_MUXPAIR", "This CSR location represents a side-effecting write alias. A write to\nthis address:\n\n-   updates `$INCOMING_MUX` with the value written\n-   also results in a delayed write to the `$INCOMING_MUX` register of\n    the paired *Tile* instance. The value written to the `$INCOMING_MUX`\n    register of the paired Tile instance is that appropriate for an\n    incoming 64-bit exchange from the specified Tile Id (see\n    timpl_tpair_writepairedincoming_mux). See timpl_exchange_parameters\n    for the delay value.\n-   will result in a exception being raised by both *Tile* instances if\n    the attempted update of the paired *Tile\\'s* `$INCOMING_MUX`\n    register coincides with a write to `$INCOMING_MUX` performed by that\n    *Tile* instance.\n\n## Note\n\nWrites to this register may cause *exception event*s to be raised by the\npaired *Tile* instance (see `$INCOMING_MUXPAIR`).\n"),
        ("f16v2exp", "* `f16v2exp $aDst0, $aSrc0`\n\n\n"),
        ("abs", "* `abs $mDst0, $mSrc0`\n\nAbsolute value of signed 32-bit integer.\n"),
        ("f16v2tanh", "* `f16v2tanh $aDst0, $aSrc0`\n\n\n"),
        ("exitneg", "* `exitneg $mSrc0`\n\nTerminate current execution of a *Worker* thread and return a Boolean\nexit status to the *Supervisor* thread. This instruction passes control\nfrom a *Worker* thread to the *Supervisor* thread. The currently\nallocated thread execution slot is returned to the *Supervisor*, which\nmay reassign the execution slot to another task.\n"),
        ("fnop", "Do nothing for one cycle (aux pipeline). Alias for `or $azero, $azero, 0`\n"),
        ("ldz8", "* `ldz8 $mDst0, $mBase0, $mDelta0, $mOff0`\n* `ldz8 $mDst0, $mBase0, $mDelta0, zimm12`\n\nLoad and zero-extend a single, 8-bit quantity fromTile Memory.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is a 32-bit value formed by zero-extending the 8-bit\n        loaded data value.\n"),
        ("ld32step", "* `ld32step $mDst0, $mBase0, $mDelta0+=, simm8`\n* `ld32step $mDst0, $mBase0, $mDelta0+=, $mStride0`\n* `ld32step $aDst0, $mBase0, $mDelta0+=, simm8`\n* `ld32step $aDst0, $mBase0, $mDelta0+=, $mStride0`\n\nNaturally aligned single *word* load with scaled post-incrementing\naddress.\n\nDestination register-file: MRF or ARF\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is an unmodified 32-bit value.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("$m6", "`$m6` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("exitpos", "* `exitpos $mSrc0`\n\nTerminate current execution of a *Worker* thread and return a Boolean\nexit status to the *Supervisor* thread. This instruction passes control\nfrom a *Worker* thread to the *Supervisor* thread. The currently\nallocated thread execution slot is returned to the *Supervisor*, which\nmay reassign the execution slot to another task.\n"),
        ("f32v2grand", "* `f32v2grand $aDst0:Dst0+1`\n\nGaussian distribution, 2-element *single-precision* random vector\n"),
        ("$INCOMING_DCOUNT", "**Read-only** CSR alias. See `$INCOMING_DCOUNT`.\n"),
        ("f16v4istacc", "* `f16v4istacc $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\nSort/shuffle (permute) through accumulators, with new input.\n\n-   Present 128-bits of register operand source data to be\n    sorted/shuffled (other otherwise permuted) using the \\$AACC state.\n    The precise behaviour is dependent on the value of the immediate.\n-   Perform \\$AACC state propagation as specified by the immediate.\n-   The destination register pair is written with 64-bits of result\n    data from a combination of \\$AACC registers. The precise\n    combination is specified by the immediate.\n"),
        ("$EXCHANGE_ADJ", "Exchange configuration adjustment register.\n"),
        ("f32v2cmplt", "* `f32v2cmplt $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2cmplt $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector less-than test\n"),
        ("or", "* `or $mDst0, $mSrc0, $mSrc1`\n* `or $mDst0, $mSrc0, zimm12`\n* `or $mDst0, $mSrc0, immz12`\n* `or $aDst0, $aSrc0, $aSrc1`\n* `or $aDst0, $aSrc0, zimm12`\n* `or $aDst0, $aSrc0, immz12`\n\nCompute the bitwise-OR of 1 32-bit register source value with 1 32-bit\nregister or 1 *zero extended*/*zero tailed* 12-bit immediate value.\n"),
        ("$m4", "`$m4` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("shr", "* `shr $mDst0, $mSrc0, $mSrc1`\n* `shr $mDst0, $mSrc0, zimm12`\n\nPerform a logical right shift, of up-to 31-bits, on a register value.\n"),
        ("sort4x32lo", "* `sort4x32lo $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\nPerform SIMD *sort* permutation on 4 x 32-bit values, across 2 source\nregister-pairs, producing a 2 x 32-bit result.\n"),
        ("andc64", "* `andc64 $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n64-bit bitwise logical AND of first ARF source register-pair with the\nbitwise negated value of a second ARF source register-pair.\n"),
        ("$a4", "`$a4` general purpose arithmetic register.\n"),
        ("$a0", "`$a0` general purpose arithmetic register.\n"),
        ("f32toi32", "* `f32toi32 $aDst0, $aSrc0`\n\nConvert a *single-precision* floating-point value to a signed integer,\nrounding as per `$FP_CTL.RND`.\n"),
        ("$WSR", "Worker context status register.\n\n## Note\n\nThe value of this register is retained between worker termination via\nexit and launch via run.\n"),
        ("f16v2min", "* `f16v2min $aDst0, $aSrc0, $aSrc1`\n\n*Half-precision* floating-point vector element-wise minimum\n"),
        ("$DBG_ECLR", "CSR alias. See `$DBG_ECLR`. Note that a write from a `put` wins over a\nsimultaneous write via this alias.\n"),
        ("$PRNG_0_1", "The most significant 32-bits of \\$PRNG_0.\n\n## Note\n\nThe value of this register is retained between worker exit and launch.\n"),
        ("f32v2absadd", "* `f32v2absadd $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Single-precision* 2-element vector element-wise addition of absolute\nvalues.\n"),
        ("rpt", "* `rpt $mSrc0, zimm8`\n* `rpt zimm12, zimm8`\n\n*rpt* provides a zero-overhead loop facility, causing the subsequent\nsequence of *Execution Bundle*s (the repeat-body) to be executed\nrepeatedly. The repeat-count can be provided as an immediate or as an\nunsigned register source value. The size of the repeat-body is expressed\nin whole Execution Bundles and provided by an immediate (with the\nrepeat-body size being (immediate + 1) *Execution Bundle*s). Note that\nit is not possible to execute solo instructions within a repeat-body. A\n*exception* will be raised in an attempt to execute a solo instruction.\n\nIf the repeat-count is zero initially, *rpt* will act as a branch over\nthe repeat-body. Otherwise, the subsequent repeat-body *Execution\nBundle*s will be executed repeat-count times.\n\nAny instruction co-issued with *rpt* is executed only once, and is not\npart of the repeat-body.\n\n`control` and `system` instructions cannot be executed within the\nrepeat-body. A exception will be raised in an attempt to execute any\nsuch instruction within the body of *rpt*.\n\nExceptions raised during the execution of the repeat-body will always be\ntreated as malign, regardless of the underlying exception type\n(including Debug exceptions). When such exceptions arise, `$WSR.ERPT` is\nset to 0b1 to indicate that the event is unrecoverable.\n"),
        ("$DBG_BRK_ID", "Id of BRK channel which caused the last BREAK *exception event*. See\ndebug_model.\n\n## Note\n\nFor Worker contexts, the value of this register is retained between\nworker exit and launch.\n"),
        ("f32sqrt", "* `f32sqrt $aDst0, $aSrc0`\n\nComputes the square root of a single precision floating-point register\nsource.\n"),
        ("$a7", "`$a7` general purpose arithmetic register.\n"),
        ("get", "* `get $mDst0, zimm8`\n\nRead the value of a control/status register into a general purpose\nregister. See control_and_status_registers.\n"),
        ("f32log2", "* `f32log2 $aDst0, $aSrc0`\n\n\n"),
        ("f32cmplt", "* `f32cmplt $aDst0, $aSrc0, $aSrc1`\n\nTest if a floating-point number is less than a second floating-point\nnumber. If so, the destination register is set to , otherwise it is set\nto .\n"),
        ("f16v8sqacc", "* `f16v8sqacc $aSrc0:Src0+3`\n\n*Half-precision* 8-element vector accumulation of squares to\n*single-precision*.\n"),
        ("f32class", "* `f32class $aDst0, $aSrc0`\n\n*Single-precision* floating-point number classifier. IEEE 754-2008:\n5.7.2\n"),
        ("f32v2cmpge", "* `f32v2cmpge $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2cmpge $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector greater-than or equal-to test\n"),
        ("brzdec", "* `brzdec $mSrcDst0, zimm19`\n\n::: spec\nbrzdec_instruction_0xaef46144e226b571\n\nConditional branch to absolute address with counter decrement. Branch\ntaken if and only if counter register value **is 0**. Counter value\ndecremented by 1 regardless of whether branch taken or not taken.\nImmediate provides word-addressed absolute destination address.\n\n## Note\n\nThis instruction considers the floating-point *single-precision* value\n-0.0 to not be equal to zero (+0.0)\n"),
        ("ld2x64pace", "* `ld2x64pace $aDst0:Dst0+1, $aDst1:Dst1+1, $mAddr0:Addr0+1+=, $mStride0, Strimm2x2`\n\nNaturally aligned dual 64-bit load, with dual independent\npost-incrementing addresses.\n\nDestination register-file: ARF only\n\nEffective addresses:\n\n:   -   2 independent load addresses\n    -   provided directly from MRF as a register pair\n    -   lower register provides 1st load address\n    -   upper register provides 2nd load address\n\nData format:\n\n:   -   Results are 2 unmodified 64-bit values stored in 2 naturally\n        aligned register pairs.\n\nNote that a TEXCPT_INVALID_OP exception will occur if the two\ndestination register pairs are not distinct.\n"),
        ("f16v4cmpeq", "* `f16v4cmpeq $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4cmpeq $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4cmpeq $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector equality test\n"),
        ("f32v2cmple", "* `f32v2cmple $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2cmple $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector less-than or equal-to test\n"),
        ("$INCOMING_FORMAT", "See exchange_internal_receive and timpl_tileincomingformat\n"),
        ("f32exp", "* `f32exp $aDst0, $aSrc0`\n\n\n"),
        ("$INCOMING_MUX", "Reset value is dependent on `$TILE_ID`. See timpl_tile_incomingmuxreset.\n\n## Note\n\nA *exception event* will be raised by this *Tile* if any of the\nfollowing conditions are met:\n\n-   a write to this CSR (by the local *Tile*) collides with a write\n    initiated by the neighbour Tile via its `$INCOMING_MUXPAIR`\n    register.\n-   the neighbour *Tile* instance attempts to write a value within the\n    external exchange range via its `$INCOMING_MUXPAIR` register.\n-   the neighbour *Tile* instance attempts to write a value within the\n    internal exchange range (via its `$INCOMING_MUXPAIR` register)\n    when the current value is within the external exchange range.\n"),
        ("$m13", "`$m13` Vertex Base Register. Initialised on behalf of a Worker context by the Supervisor via `run` or `runall`. This register can also be read through the `$vertex_base` alias.\n"),
        ("$fp", "Alias for `$m5`. Frame Pointer. Points to the part of the stack used by the current function.\n"),
        ("f32exp2", "* `f32exp2 $aDst0, $aSrc0`\n\n\n"),
        ("$DBG_DATA", "CSR alias. See `$DBG_DATA`. Note that a write from a `put` wins over a\nsimultaneous write via this alias.\n"),
        ("f32v4acc", "* `f32v4acc $aSrc0:Src0+3`\n\n*Single-precision* 4-element vector accumulation to *Single-precision*.\n"),
        ("mov", "Copy the value in `$mSrc` to `mDst`. This compiles to `or` or `atom` instructions.\n"),
        ("ld64b16pace", "* `ld64b16pace $aDst0:Dst0+1, $aDst1, $mAddr0:Addr0+1+=, $mStride0, Strimm2x2`\n\nNaturally aligned 64-bit and broadcast 16-bit load, with dual\nindependent post-incrementing addresses.\n\nDestination register-file: ARF only\n\nEffective addresses:\n\n:   -   2 independent full load addresses\n    -   provided directly from MRF as a register pair\n    -   lower register provides 1st load address\n    -   upper register provides 2nd load address\n\nData format:\n\n:   -   Results are:\n        -   1 unmodified 64-bit value stored in a naturally aligned\n            register pair\n        -   1 16-bit value broadcast (duplicated) into a single ARF\n            register\n\nNote that a TEXCPT_INVALID_OP exception will occur if the two\ndestination register pairs are not distinct.\n"),
        ("f32cmpne", "* `f32cmpne $aDst0, $aSrc0, $aSrc1`\n\nTest if a floating-point number is not equal to second floating-point\nnumber. If so, the destination register is set to , otherwise it is set\nto .\n"),
        ("$m10", "`$m10` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("$a14", "`$a14` register. Always reads 0. Also available through the `$azero` or `$azeros` (64-bit) alias.\n"),
        ("st64pace", "* `st64pace $aSrc0:Src0+1, $mAddr0:Addr0+1+=, $mStride0, Strimm2`\n\nNaturally aligned 64-bit store with scaled post-incrementing address.\n\nSource register-file: ARF only (a naturally aligned register-pair)\n\nEffective address:\n\n:   -   Absolute address 2 from a triple packed address register pair\n"),
        ("f32mac", "* `f32mac $aSrc0, $aSrc1`\n\n*Single-precision* floating-point multiplication of two source registers\nwith *single-precision* accumulate.\n"),
        ("f32mul", "* `f32mul $aDst0, $aSrc0, $aSrc1`\n\nSingle precision floating-point multiplication on 2 source register\nvalues.\n"),
        ("f16v4mul", "* `f16v4mul $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4mul $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4mul $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector, Hadamard product\n"),
        ("mul", "* `mul $mDst0, $mSrc0, $mSrc1`\n* `mul $mDst0, $mSrc0, simm16`\n\nMultiply a signed 32-bit register source value with a signed 32-bit\nregister or sign extended 16-bit immediate.\n"),
        ("sort8x8hi", "* `sort8x8hi $mDst0, $mSrc0, $mSrc1`\n\nPerform SIMD *sort* permutation on 8 x 8-bit values, across 2 source\nregisters, returning the upper *word* of the result. See [sort8x8lo]()\nfor lower *word*.\n"),
        ("$DBG_IEXEC", "If the target *context* (given by `$DBG_IOWNER`) is a *Worker* context:\n\n-   If the target context is *quiescent*, writes to this register will\n    cause the value written to be be injected as an instruction into the\n    instruction stream of the target *context*. Such writes will also\n    cause the busy flag to be set to 0b1.\n-   If the target *context* is not *quiescent*, writes to this register\n    will result in the setting of to 0b1. The contents of will not be\n    modified.\n\nIf the target context is the *Supervisor* context:\n\n-   Writes to this register will cause the value written to be injected\n    as an instruction into the instruction stream of the Supervisor\n    context under the following conditions:\n    -   The Supervisor context is in theExcepted state\n    -   The Supervisor context is in any other *quiescent* state and\n        RBRK is enabled for the Supervisor context\n-   Otherwise, writes to this register will result in the setting of to\n    0b1. The contents of will not be modified.\n\nValues written to must constitute correctly formed, complete instruction\nopcode values, including all field information. Note that the following\ninstructions cannot be injected into either the Supervisor or any Worker\ncontext. Any attempt to inject any such instruction will result in being\nset to 0b1 (the contents of will not be modified):\n\nInjected instructions cannot raise BREAK *exception event*s. IBRKs,\nDBRKs and RBRKs do not apply to injected instructions. Since `sync` and\ninstructions cannot be injected, break_on_sync and PBRKs also don\\'t\napply. Similarly, post-execution exceptions ( which include exchange\nparity errors, internal exchange receive errors, external exchange\nreceive errors and and memory parity/ECC errors raised by other\ncontexts) also don\\'t apply to injected instructions. However, if an\ninjected instruction would result in a FAULT *exception event* (not\ncaused by any of the exceptions listed above) and the *context*:\n\n-   Is not in theExcepted state, the appropriate (unrecoverable)\n    *exception event* will be raised in the normal manner.\n-   Is in theExcepted state, will be set to 0b1 (and the exception\n    logging state may or may not be updated - implementation_specifics)\n\nOnce an injected instruction has retired will be cleared to 0b0.\n\n## Note\n\nWrites to will be ignored if any of the error flags in of the `$TDI_STS`\nare set. Those flags can be cleared via `$TDI_CLR`.\n"),
        ("andc", "* `andc $mDst0, $mSrc0, $mSrc1`\n* `andc $mDst0, $mSrc0, zimm12`\n* `andc $aDst0, $aSrc0, $aSrc1`\n* `andc $aDst0, $aSrc0, zimm12`\n* `andc $aDst0, $aSrc0, immz12`\n\nBitwise logical AND of first source register value with the bitwise\nnegated value of a second source register value or *zero extended*/*zero\ntailed* immediate.\n"),
        ("f32fromi32", "* `f32fromi32 $aDst0, $aSrc0`\n\nConvert a signed integer to a *single-precision* floating-point value.\n"),
        ("not64", "* `not64 $aDst0:Dst0+1, $aSrc0:Src0+1`\n\nCompute the bitwise logical NOT of a 64-bit ARF register-pair.\n"),
        ("f32v2clamp", "* `f32v2clamp $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector min-of-maximum\n"),
        ("f32v4absacc", "* `f32v4absacc $aSrc0:Src0+3`\n\n*Single-precision* 4-element vector accumulation of absolute values to\n*single-precision*.\n"),
        ("xor", "* `xor $mDst0, $mSrc0, $mSrc1`\n\nBitwise-XOR of two register values.\n"),
        ("$FP_CTL", "Floating-point control register.\n\n## Note\n\nThe initial value of this register on worker launch is provided by .\n"),
        ("f32int", "* `f32int $aDst0, $aSrc1, enumRnd`\n\nRound a *single-precision* floating-point value to an integral, rounding\nas specified by the instruction immediate.\n"),
        ("brnzdec", "* `brnzdec $mSrcDst0, zimm19`\n\nConditional branch to absolute address with counter decrement. Branch\ntaken and counter value decremented by 1 if and only if counter register\nvalue **is not 0**. Immediate provides word-addressed absolute\ndestination address.\n\n## Note\n\nThis instruction considers the floating-point *single-precision* value\n-0.0 to not be equal to zero (+0.0)\n"),
        ("f16v2clamp", "* `f16v2clamp $aDst0, $aSrc0, $aSrc1`\n\n*Half-precision* floating-point vector min-of-maximum\n"),
        ("f16v4cmac", "* `f16v4cmac $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Half-precision* floating-point vector element-wise multiply with\n*single-precision* 2x2 lateral sum and accumulate.\n"),
        ("$COUNT_U", "[Tile]{.title-ref} cycle counter value. Upper 32-bits\n"),
        ("f32clamp", "* `f32clamp $aDst0, $aSrc0, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector min-of-maximum\n"),
        ("ldz16step", "* `ldz16step $mDst0, $mBase0, $mDelta0+=, simm8`\n* `ldz16step $mDst0, $mBase0, $mDelta0+=, $mStride0`\n\nZero-extending, naturally aligned 16-bit load with scaled\npost-incrementing address.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is a 32-bit value formed by zero-extending the 16-bit\n        data value.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("ld128step", "* `ld128step $aDst0:Dst0+3, $mBase0, $mDelta0+=, simm8`\n* `ld128step $aDst0:Dst0+3, $mBase0, $mDelta0+=, $mStride0`\n\nNaturally aligned 128-bit load from interleaved memory region with\nscaled post-incrementing address.\n\nDestination register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is an unmodified 128-bit value stored in a naturally\n        aligned register-quad.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("f16v4hihov4amp", "* `f16v4hihov4amp $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\n*Half-precision* floating-point accumulating matrix-vector product.\nInput and result partial-sums are 4-element *half-precision* vectors.\n"),
        ("f16v4cmpne", "* `f16v4cmpne $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4cmpne $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4cmpne $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector inequality test\n"),
        ("uget", "* `uget $aDst0, zimm8`\n\nRead the value of a control/status register into a general purpose\nregister. See control_and_status_registers.\n"),
        ("f16v2grand", "* `f16v2grand $aDst0`\n\nGaussian distribution, 2-element *half-precision* random vector\n"),
        ("ldz8step", "* `ldz8step $mDst0, $mBase0, $mDelta0+=, simm8`\n* `ldz8step $mDst0, $mBase0, $mDelta0+=, $mStride0`\n\nZero-extending 8-bit load with post-incrementing address.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is a 32-bit value formed by zero-extending the 8-bit data\n        value.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register.\n"),
        ("f16v4sum", "* `f16v4sum $aDst0:Dst0+1, $aSrc0:Src0+1`\n\n*Half-precision* 4-element vector 2x2 lateral summation to 2-element\n*single-precision* vector.\n"),
        ("$CR", "Supervisor Control Register.\n"),
        ("movz", "* `movz $mSrcDst0, $mSrc0, $mSrc1`\n\nConditional copy of one register into another, gated on the value of a\nthird.\n"),
        ("f32sub", "* `f32sub $aDst0, $aSrc0, $aSrc1`\n\nSubtracts two floating-point values.\n"),
        ("f16v2gina", "* `f16v2gina $aDst0, $aSrc0, zimm12`\n\nGet and initialise accumulators.\n\n-   Read a pair of internal accumulator values as *half-precision*\n    values. Stochastic rounding applies as configured by\n    `$FP_CTL.ESR`.\n>\n-   Convert 2-element vector of *half-precision* input values to\n    single precision and write to internal accumulator state.\n>\n-   The instruction immediate specifies which pair of accumulator\n    registers are to be read and written:\n>\n    > a.  Read **\\$AACC**\\[0\\] and **\\$AACC**\\[2\\], write\n    >     **\\$AACC**\\[12\\] and **\\$AACC**\\[14\\]\n    > b.  Read **\\$AACC**\\[1\\] and **\\$AACC**\\[3\\], write\n    >     **\\$AACC**\\[13\\] and **\\$AACC**\\[15\\]\n    >\n    > and if and only if the platform supports 2 AMP sets:\n    >\n    > c.  Read **\\$AACC**\\[16\\] and **\\$AACC**\\[18\\], write\n    >     **\\$AACC**\\[28\\] and **\\$AACC**\\[30\\]\n    > d.  Read **\\$AACC**\\[17\\] and **\\$AACC**\\[19\\], write\n    >     **\\$AACC**\\[29\\] and **\\$AACC**\\[31\\]\n>\n-   Propagate internal accumulator state such that all accumulator\n    registers may be read and written via a sequence of this\n    instruction.\n\nzimm12 immediate format:\n\n![f16v2gina immediate\nformat](images/autogen/GINA_IMMFLAGS.*){.align-center}\n"),
        ("f16v2cmpeq", "* `f16v2cmpeq $aDst0, $aSrc0, $aSrc1`\n* `f16v2cmpeq $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2cmpeq $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* 2-element vector equality test\n"),
        ("$a2:3", "`$a2` and `$a3` together as a 64-bit general purpose arithmetic register.\n"),
        ("add", "* `add $mDst0, $mSrc0, $mSrc1`\n* `add $mDst0, $mSrc0, zimm16`\n* `add $mDst0, $mSrc0, simm16`\n\nSigned integer addition of 2 source register values, or 1 source\nregister and 1 immediate. Immediates may be *sign extended* or *zero\nextended* to *word* width. No scaling of the source operands (register\nor immediate) is performed.\n"),
        ("$REPEAT_COUNT", "The number of repetitions of a `rpt` repeat-body remaining. Note that\nany *exception* detected when `$REPEAT_COUNT` is non-zero will be\ntreated as malign (including Debug exceptions).\n\n## Note\n\nThe value of this register is retained between worker exit and launch.\n\n::: spec\nrepeat_count_width_0xf91c7131e8ca1572\n\n`$REPEAT_COUNT.VALUE` register field is 16 bits wide.\n"),
        ("f16v8absacc", "* `f16v8absacc $aSrc0:Src0+3`\n\n*Half-precision* 8-element vector accumulation of absolute values to\n*single-precision*.\n"),
        ("f32oorx", "* `f32oorx $aDst0, $aSrc0`\n\n*Single-precision* reciprocal of square-root.\n"),
        ("sort4x16lo", "* `sort4x16lo $mDst0, $mSrc0, $mSrc1`\n* `sort4x16lo $aDst0, $aSrc0, $aSrc1`\n* `sort4x16lo $aDst0, $aSrc0:BU, $aSrc1`\n\nPerform SIMD *sort* permutation on 4 x 16-bit values, across 2 source\nregisters, producing a 2 x 16-bit result.\n"),
        ("shrs", "* `shrs $mDst0, $mSrc0, $mSrc1`\n* `shrs $mDst0, $mSrc0, zimm12`\n\nPerform an arithmetic right shift (the sign-bit is shifted in), of up-to\n31-bits, on a register value.\n"),
        ("$PRNG_1_0", "The least significant 32-bits of \\$PRNG_1.\n\n## Note\n\nThe value of this register is retained between worker exit and launch.\n"),
        ("$sp", "The stack pointer (an alias for `$m7`). This register is commonly used to hold the address of the bottom of the stack.\n"),
        ("brneg", "* `brneg $mSrc0, zimm19`\n\nConditional branch to absolute address. Branch taken if and only if\nregister value **is negative**. Immediate provides word-addressed\nabsolute destination address.\n"),
        ("or64", "* `or64 $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\nCompute the bitwise logical OR of 1 ARF register-pair source value with\na 2nd ARF register-pair.\n"),
        ("$DBG_IOWNER", "\n"),
        ("f16v4clamp", "* `f16v4clamp $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1`\n\n*Half-precision* floating-point vector min-of-maximum\n"),
        ("zero", "Zero the register. Alias for `or $mDest, $mzero, 0`, `or $aDest, $azero, 0` or `or64 $aDest:1, $azeros, 0`.\n"),
        ("brpos", "* `brpos $mSrc0, zimm19`\n\nConditional branch to absolute address. Branch taken if and only if\nregister value **is positive**. Immediate provides word-addressed\nabsolute destination address.\n"),
        ("$m7", "`$m7` is used as the stack pointer. Also available through `$sp`.\n"),
        ("ldb16", "* `ldb16 $aDst0, $mBase0, $mDelta0, $mOff0`\n* `ldb16 $aDst0, $mBase0, $mDelta0, zimm12`\n\nLoad and broadcast a single, naturally aligned 16-bit quantity fromTile\nMemory.\n\nDestination register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is a 32-bit value formed by broadcasting (duplicating)\n        the 16-bit data value.\n"),
        ("$DBG_CTL", "Debug control register. See debug_model.\n"),
        ("ld2xst64pace", "* `ld2xst64pace $aDst0:Dst0+3, $aSrc0:Src0+1, $mAddr0:Addr0+1+=, $mStride0, Strimm3x2`\n\nNaturally aligned dual 64-bit load and simultaneous 64-bit store, with 3\nindependent post-incrementing addresses.\n\nDestination register-file: ARF only\n\nSource register-file: ARF only\n\nEffective addresses:\n\n:   -   3 independent addresses provided directly from MRF, packed into\n        a register pair\n\nData format:\n\n:   -   Load results are 2 unmodified 64-bit values stored in a\n        naturally aligned register quad.\n"),
        ("f16v4cmple", "* `f16v4cmple $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4cmple $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4cmple $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector less-than or equal-to test\n"),
        ("f16v2cmplt", "* `f16v2cmplt $aDst0, $aSrc0, $aSrc1`\n* `f16v2cmplt $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2cmplt $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector less-than test\n"),
        ("f16v4sihoamp", "* `f16v4sihoamp $aDst0, $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\n*Half-precision* floating-point vector accumulating matrix-vector\nproduct. Input partial-sums are *single-precision*. Result values are\n*half-precision*.\n"),
        ("$REPEAT_END", "The address of the very next instruction following the current (previous\nif not currently executing a repeat block) `rpt` repeat-body.\n\n## Note\n\nThe value of this register is *undefined* at worker launch\n"),
        ("f16v2ln", "* `f16v2ln $aDst0, $aSrc0`\n\n\n"),
        ("roll8l", "* `roll8l $mDst0, $mSrc0, $mSrc1`\n\nPerform a SIMD *roll-left* permutation on the 8 x 8-bit values across 2\nsource registers.\n"),
        ("$PC", "Context Program Counter.\n\n## Note\n\nFor Worker contexts, the initial value of this register following worker\nlaunch is set by the Supervisor run instruction.\n"),
        ("ld64step", "* `ld64step $aDst0:Dst0+1, $mBase0, $mDelta0+=, simm8`\n* `ld64step $aDst0:Dst0+1, $mBase0, $mDelta0+=, $mStride0`\n\nNaturally aligned 64-bit load with scaled post-incrementing address.\n\nDestination register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is an unmodified 64-bit value stored in a naturally\n        aligned register-pair.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("$DBG_RBRK", "Used by external agents to enable Retirement BREAK *exception event*s\n(see retirement_brk) on anyTile context.\n"),
        ("call", "* `call $mDst0, zimm20`\n\nUnconditional absolute branch and link. Save the next value of **\\$PC**\ninto a general purpose register and perform an unconditional branch.\nImmediate provides word-addressed absolute destination address.\n\n## Note\n\nBit 19 of the immediate is ignored\n"),
        ("$EXCHANGE_CTL", "**Read-only** CSR alias. See `$EXCHANGE_CTL`.\n"),
        ("xnor", "* `xnor $mDst0, $mSrc0, $mSrc1`\n\nThe complement of the bitwise-XOR of two register values.\n"),
        ("roll32", "* `roll32 $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\nPerform a SIMD *roll* permutation on the 4 x 32-bit values across 2\nsource registers-pairs.\n"),
        ("f32max", "* `f32max $aDst0, $aSrc0, $aSrc1`\n\nDetermine the maximum floating-point value from two register source\nvalues.\n"),
        ("f32fromui32", "* `f32fromui32 $aDst0, $aSrc0`\n\nConvert an unsigned integer to a *single-precision* floating-point\nvalue.\n"),
        ("f32cmpge", "* `f32cmpge $aDst0, $aSrc0, $aSrc1`\n\nTest if a floating-point number is greater than or equal to a second\nfloating-point number. If so, the destination register is set to ,\notherwise it is set to .\n"),
        ("$m12", "`$m12` Worker Base Register. Returns the worker context scratch space base address. Also available through the alias `$worker_base`.\n"),
        ("shl", "* `shl $mDst0, $mSrc0, $mSrc1`\n* `shl $mDst0, $mSrc0, zimm12`\n\nPerform a logical left shift, of up-to 31-bits, on a register value.\n"),
        ("f16v4cmplt", "* `f16v4cmplt $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4cmplt $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4cmplt $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector less-than test\n"),
        ("ld128", "* `ld128 $aDst0:Dst0+3, $mBase0, $mDelta0, $mOff0`\n* `ld128 $aDst0:Dst0+3, $mBase0, $mDelta0, zimm12`\n\nLoad a single, naturally aligned 128-bit quantity from an interleaved\nregion ofTile Memory.\n\nDestination register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is an unmodified 128-bit value stored in a naturally\n        aligned register-quad.\n"),
        ("f16v2class", "* `f16v2class $aDst0, $aSrc0`\n\n*Half-precision* floating-point vector classifier. IEEE 754-2008: 5.7.2\n"),
        ("f16v2log2", "* `f16v2log2 $aDst0, $aSrc0`\n\n\n"),
        ("f16v2cmple", "* `f16v2cmple $aDst0, $aSrc0, $aSrc1`\n* `f16v2cmple $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2cmple $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector less-than test\n"),
        ("$SCOUNT_L", "[Tile]{.title-ref} cycle counter value. Lower 32-bits. An explicit write\nvia `put` always wins over hardware clock tick.\n"),
        ("f32v2min", "* `f32v2min $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Single-precision* 2-element vector element-wise minimum\n"),
        ("f16v4cmpgt", "* `f16v4cmpgt $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4cmpgt $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4cmpgt $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector greater-than test\n"),
        ("runall", "* `runall $mEntry0, $mVBase0, zimm16`\n\nAllocate execution time and context state to a batch of worker\n*thread*s:\n\n-   The total number of *thread*s launched is equal to the number of\n    hardware *worker* contexts ()\n>\n-   All *thread*s use the same entry point (\\$mEntry0)\n>\n-   The value of `$VERTEX_BASE` assigned to the first allocated\n    *worker* is provided by the register \\$mVBase0\n>\n-   The value of `$VERTEX_BASE` assigned to every other *worker* is:\n>\n    > -   \\$mVBase0 + (*n* × zimm16 × 4) (\\$n in {\\[1, CTXT_WORKERS -\n    >     1\\]}\\$)\n\n*Exception event*s will be raised for any of the following conditions:\n\n-   \\$mEntry0 is not 4-byte aligned\n-   \\$mVBase0 is not 4-byte aligned\n-   \\$mEntry0 is not a valid, executable address\n-   There are any active Worker contexts\n\nIf there are active Worker contexts, `$SSR.RAERR` will also be set to\n0b1 and all active Workers will raise a exception during the retirement\nof their next instruction.\n"),
        ("$m5", "`$m5` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("f16v2sum", "* `f16v2sum $aDst0, $aSrc0`\n\n*Half-precision* 2-element vector lateral summation to\n*single-precision*.\n"),
        ("f16v4sisoslic", "* `f16v4sisoslic $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\n*f16* floating-point slim convolution. Input and result partial-sums are\n2 x *single-precision* values.\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1    \\$AACC\\[14\\]   \\$AACC\\[10\\]           \\$AACC\\[6\\]         \\$AACC\\[2\\]        \\$AACC\\[12\\]   \\$AACC\\[8\\]            \\$AACC\\[4\\]         \\$AACC\\[0\\]        \\$aDst0\n  ------------- -------------- ---------------------- ------------------- ------------------ -------------- ---------------------- ------------------- ------------------ ---------\n  x0\\|P0,P1     **-**          R1=x0.**CW**5,0+P1     **-**               **-**              **-**          R0=x0.**CW**4,0+P0     **-**               **-**              **-**\n\n  x1\\|P2,P3     **-**          R3=x1.**CW**5,0+P3     R1+=x1.**CW**3,0    **-**              **-**          R2=x1.**CW**4,0+P2     R0+=x1.**CW**2,0    **-**              **-**\n\n  x2\\|P4,P5     **-**          R5=x2.**CW**5,0+P5     R3+=x2.**CW**3,0    R1+=x2.**CW**1,0   **-**          R4=x2.**CW**4,0+P4     R2+=x2.**CW**2,0    R0+=x2.**CW**0,0   **-**\n\n  x3\\|P6,P7     **-**          R7=x3.**CW**5,0+P7     R5+=x3.**CW**3,0    R3+=x3.**CW**1,0   **-**          R6=x3.**CW**4,0+P6     R4+=x3.**CW**2,0    R2+=x3.**CW**0,0   R0,R1\n\n  x4\\|P8,P9     **-**          R9=x4.**CW**5,0+P9     R7+=x4.**CW**3,0    R5+=x4.**CW**1,0   **-**          R8=x4.**CW**4,0+P8     R6+=x4.**CW**2,0    R4+=x4.**CW**0,0   R2,R3\n\n  x5\\|P10,P11   **-**          R11=x5.**CW**5,0+P11   R9+=x5.**CW**3,0    R7+=x5.**CW**1,0   **-**          R10=x5.**CW**4,0+P10   R8+=x5.**CW**2,0    R6+=x5.**CW**0,0   R4,R5\n\n  x6\\|P12,P13   **-**          R13=x6.**CW**5,0+P13   R11+=x6.**CW**3,0   R9+=x6.**CW**1,0   **-**          R12=x6.**CW**4,0+P12   R10+=x6.**CW**2,0   R8+=x6.**CW**0,0   R6,R7\n  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f16v4sisoslic, 2x1x3x4 example sequence\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1    \\$AACC\\[14\\]           \\$AACC\\[10\\]        \\$AACC\\[6\\]        \\$AACC\\[2\\]        \\$AACC\\[12\\]           \\$AACC\\[8\\]         \\$AACC\\[4\\]        \\$AACC\\[0\\]        \\$aDst0\n  ------------- ---------------------- ------------------- ------------------ ------------------ ---------------------- ------------------- ------------------ ------------------ ---------\n  x0\\|P0,P1     R1=x0.**CW**7,0+P1     **-**               **-**              **-**              R0=x0.**CW**6,0+P0     **-**               **-**              **-**              **-**\n\n  x1\\|P2,P3     R3=x1.**CW**7,0+P3     R1+=x1.**CW**5,0    **-**              **-**              R2=x1.**CW**6,0+P2     R0+=x1.**CW**4,0    **-**              **-**              **-**\n\n  x2\\|P4,P5     R5=x2.**CW**7,0+P5     R3+=x2.**CW**5,0    R1+=x2.**CW**3,0   **-**              R4=x2.**CW**6,0+P4     R2+=x2.**CW**4,0    R0+=x2.**CW**2,0   **-**              **-**\n\n  x3\\|P6,P7     R7=x3.**CW**7,0+P7     R5+=x3.**CW**5,0    R3+=x3.**CW**3,0   R1+=x3.**CW**1,0   R6=x3.**CW**6,0+P6     R4+=x3.**CW**4,0    R2+=x3.**CW**2,0   R0+=x3.**CW**0,0   **-**\n\n  x4\\|P8,P9     R9=x4.**CW**7,0+P9     R7+=x4.**CW**5,0    R5+=x4.**CW**3,0   R3+=x4.**CW**1,0   R8=x4.**CW**6,0+P8     R6+=x4.**CW**4,0    R4+=x4.**CW**2,0   R2+=x4.**CW**0,0   R0,R1\n\n  x5\\|P10,P11   R11=x5.**CW**7,0+P11   R9+=x5.**CW**5,0    R7+=x5.**CW**3,0   R5+=x5.**CW**1,0   R10=x5.**CW**6,0+P10   R8+=x5.**CW**4,0    R6+=x5.**CW**2,0   R4+=x5.**CW**0,0   R2,R3\n\n  x6\\|P12,P13   R13=x6.**CW**7,0+P13   R11+=x6.**CW**5,0   R9+=x6.**CW**3,0   R7+=x6.**CW**1,0   R12=x6.**CW**6,0+P12   R10+=x6.**CW**4,0   R8+=x6.**CW**2,0   R6+=x6.**CW**0,0   R4,R5\n  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f16v4sisoslic, 2x1x4x4 example sequence\n\nPn is *single-precision* input partial-sum *n* xn is an *f16v4* input\nvector **CW**m,n is the common weight state **\\$CWEI**\\_*m*\\_*n* Rn is\nthe final *single-precision* result of successive dot-product\naccumulations that began with Pn\n\nenumFlags format:\n\n![f16v4sisoslic immediate\nformat](images/autogen/F16SLIC_ENUMFLAGS.*){.align-center}\n"),
        ("not", "* `not $aDst0, $aSrc0`\n\nCompute the bitwise logical NOT of a single 32-bit ARF register.\n"),
        ("ldd16b16", "* `ldd16b16 $aDst0, $mAddr0++, $mBase0, $mDelta0@`\n\nPost-incrementing 16-bit delta load with simultaneous broadcast 16-bit\ndata load.\n\nDestination register-file: Combination of MRF and ARF\n\nEffective addresses:\n\n:   1.  A full-pointer value (`$m` register)\n    2.  Base address (`$m` register) plus 16-bit, unsigned address delta\n        (`$m` register)\n\nData format:\n\n:   1.  A 16-bit value (new delta-offset) written to the MRF delta\n        register.\n    2.  A 32-bit value formed via a broadcast operation on the 16-bit\n        loaded data value written to the ARF destination register.\n\nAddress auto-increment:\n\n:   1.  The full-pointer source register value is incremented by 2\n        (bytes).\n"),
        ("run", "* `run $mEntry0, $mVBase0, zimm16`\n\nLaunch a worker *thread*.\n\nAllocate execution time and *context* state to the *thread* whose entry\npoint is given by the register operand \\$mEntry0, using the vertex\naddress calculated by summing:\n\n1.  the register operand \\$mVBase0\n2.  the 16-bit immediate offset zimm16 × 4\n3.  the constant TMEM_REGION0_BASE_ADDR\n\n(i.e. the address formed by adding the register value \\$mVBase0 to the\nscaled immediate offset zimm16 is relative to TMEM_REGION0_BASE_ADDR)\n\n*Exception event*s will be raised for any of the following conditions:\n\n-   \\$mEntry0 is not 4-byte aligned\n-   \\$mVBase0 is not 4-byte aligned\n-   \\$mEntry0 is not a valid, executable address\n"),
        ("f16v4mix", "* `f16v4mix $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector **z** = *a***x** + *b***y**. The\nscalar multiplicands *a* and *b* are provided by the internal state\nelement `$TAS`.\n\nResults are stored within the accumulator state. Destination registers\nare written with the previous accumulator state.\n"),
        ("trap", "* `trap zimm4`\n\nUnconditionally raise a *patched breakpoint* *exception event*.\n"),
        ("f16v2mul", "* `f16v2mul $aDst0, $aSrc0, $aSrc1`\n* `f16v2mul $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2mul $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* 2-element vector, Hadamard product\n"),
        ("sort8", "* `sort8 $mDst0, $mSrc0`\n\nPerform SIMD *sort8* permutation on 4 x 8-bit values.\n"),
        ("f16v2exp2", "* `f16v2exp2 $aDst0, $aSrc0`\n\n\n"),
        ("sort8x8lo", "* `sort8x8lo $mDst0, $mSrc0, $mSrc1`\n\nPerform SIMD *sort* permutation on 8 x 8-bit values, across 2 source\nregisters, returning the lower *word* of the result. See [sort8x8hi]()\nfor upper *word*.\n"),
        ("f32v2gina", "* `f32v2gina $aDst0:Dst0+1, $aSrc0:Src0+1, zimm12`\n\nGet and initialise accumulators.\n\n-   Read a pair of internal accumulator values as *single-precision*\n    values.\n>\n-   Write 2-element vector of *single-precision* input values to\n    internal accumulator state.\n>\n-   The instruction immediate specifies which pair of accumulator\n    registers are to be read and written:\n>\n    > a.  Read **\\$AACC**\\[0\\] and **\\$AACC**\\[2\\], write\n    >     **\\$AACC**\\[12\\] and **\\$AACC**\\[14\\]\n    > b.  Read **\\$AACC**\\[1\\] and **\\$AACC**\\[3\\], write\n    >     **\\$AACC**\\[13\\] and **\\$AACC**\\[15\\]\n    >\n    > and if and only if the platform supports 2 AMP sets:\n    >\n    > c.  Read **\\$AACC**\\[16\\] and **\\$AACC**\\[18\\], write\n    >     **\\$AACC**\\[28\\] and **\\$AACC**\\[30\\]\n    > d.  Read **\\$AACC**\\[17\\] and **\\$AACC**\\[19\\], write\n    >     **\\$AACC**\\[29\\] and **\\$AACC**\\[31\\]\n>\n-   Propagate internal accumulator state such that all accumulator\n    registers may be read and written via a sequence of this\n    instruction.\n\nzimm12 immediate format:\n\n![f32v2gina immediate\nformat](images/autogen/GINA_IMMFLAGS.*){.align-center}\n"),
        ("f32v2sufromui", "* `f32v2sufromui $aDst0:Dst0+1, $aSrc0:Src0+1`\n\nSymmetric, unbiased conversion from 2-element vector of unsigned 32-bit\nintegers to 2-element *single-precision* vector.\n\nEach of the *single-precision* results lies within the range\n\\$\\[-frac{1}{2}, frac{1}{2}\\]\\$ but can never be exactly 0. All results\nwill have a magnitude of at least \\$frac{1}{2\\^{33}}\\$ (and therefore\nresults will never be inside the denormalised number range for\n*single-precision*).\n\nNote that this instruction can be combined with `urand32`/`urand64` to\nproduce random, uniformly distributed floating-point values.\n"),
        ("f32v4sqacc", "* `f32v4sqacc $aSrc0:Src0+3`\n\n*Single-precision* 4-element vector accumulation of squares to\n*single-precision*.\n"),
        ("ld64", "* `ld64 $aDst0:Dst0+1, $mBase0, $mDelta0, $mOff0`\n* `ld64 $aDst0:Dst0+1, $mBase0, $mDelta0, zimm12`\n\nLoad a single, naturally aligned 64-bit quantity fromTile Memory.\n\nDestination register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is an unmodified 64-bit value stored in a naturally\n        aligned register-pair.\n"),
        ("$mworker_base", "The Worker Base Register (an alias for `$m12`). Returns the worker context scratch space base address.\n"),
        ("$lr", "Alias for `$m6`. Link Register. This register is commonly used to hold the return address of a function.\n"),
        ("$SSR", "Supervisor Status Register.\n"),
        ("ld64a32", "* `ld64a32 $aDst0+1:Dst0+3, $mAddr0++, $mBase0, $mDelta0`\n\nPost-incrementing load of dense 64-bit value plus a sparse 32-bit value.\n\nDestination register-file: ARF only\n\nEffective addresses:\n\n:   1.  A full-pointer register value (notionally a pointer into an\n        array of dense values).\n    2.  A base address register value added to a 16-bit delta-offset\n        located in the lsbs of a third source register value.\n\nData format:\n\n:   -   Results are:\n        -   A naturally aligned 64-bit value, written to the top half of\n            the destination register quad.\n        -   A naturally aligned 32-bit data value, written to the 2nd\n            element of the destination register quad.\n\nAddress auto-increment:\n\n:   -   The full-pointer register is post-incremented by 8 (bytes)\n\n## Note\n\nThe first element of the destination register quad is unmodified.\n"),
        ("f32sisov2amp", "* `f32sisov2amp $aDst0:Dst0+1, $aSrc0, $aSrc1:Src1+1, enumFlags`\n\n*Single-precision* floating-point **a**ccumulating **m**atrix-vector\n**p**roduct. Input partial-sums and result values are\n*single-precision*.\n\nenumFlags format:\n\n![f32sisoamp immediate\nformat](images/autogen/F32AMP_ENUMFLAGS.*){.align-center}\n\n16 output channels are processed/produced.\n"),
        ("f32sisoslic", "* `f32sisoslic $aDst0:Dst0+1, $aSrc0, $aSrc1:Src1+1, enumFlags`\n\n*Single-precision* floating-point **sli**m **c**onvolution. Input\npartial-sums are *single-precision*. Results are *single-precision*.\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1     \\$AACC\\[14\\]   \\$AACC\\[10\\]             \\$AACC\\[6\\]          \\$AACC\\[2\\]          \\$AACC\\[12\\]   \\$AACC\\[8\\]              \\$AACC\\[4\\]          \\$AACC\\[0\\]          \\$aDst0\n  -------------- -------------- ------------------------ -------------------- -------------------- -------------- ------------------------ -------------------- -------------------- ---------\n  x0L\\|P0,P1     **-**          R1=x0L×**CW**5,0L+P1     **-**                **-**                **-**          R0=x0L×**CW**4,0L+P0     **-**                **-**                **-**\n\n  x0U\\|D0,D1     **-**          R1+=x0U×**CW**5,0U       **-**                **-**                **-**          R0+=x0U×**CW**4,0U       **-**                **-**                **-**\n\n  x1L\\|P2,P3     **-**          R3=x1L×**CW**5,0L+P3     R1+=x1L×**CW**3,0L   **-**                **-**          R2=x1L×**CW**4,0L+P2     R0+=x1L×**CW**2,0L   **-**                **-**\n\n  x1U\\|D2,D3     **-**          R3+=x1U×**CW**5,0U       R1+=x1U×**CW**3,0U   **-**                **-**          R2+=x1U×**CW**4,0U       R0+=x1U×**CW**2,0U   **-**                **-**\n\n  x2L\\|P4,P5     **-**          R5=x2L×**CW**5,0L+P5     R3+=x2L×**CW**3,0L   R1+=x2L×**CW**1,0L   **-**          R4=x2L×**CW**4,0L+P4     R2+=x2L×**CW**2,0L   R0+=x2L×**CW**0,0L   **-**\n\n  x2U\\|D4,D5     **-**          R5+=x2U×**CW**5,0U       R3+=x2U×**CW**3,0U   R1+=x2U×**CW**1,0U   **-**          R4+=x2U×**CW**4,0U       R2+=x2U×**CW**2,0U   R0+=x2U×**CW**0,0U   **-**\n\n  x3L\\|P6,P7     **-**          R7=x3L×**CW**5,0L+P7     R5+=x3L×**CW**3,0L   R3+=x3L×**CW**1,0L   **-**          R6=x3L×**CW**4,0L+P6     R4+=x3L×**CW**2,0L   R2+=x3L×**CW**0,0L   R0,R1\n\n  x3U\\|D6,D7     **-**          R7+=x3U×**CW**5,0U       R5+=x3U×**CW**3,0U   R3+=x3U×**CW**1,0U   **-**          R6+=x3U×**CW**4,0U       R4+=x3U×**CW**2,0U   R2+=x3U×**CW**0,0U   **-**\n\n  x4L\\|P8,P9     **-**          R9=x4L×**CW**5,0L+P9     R7+=x4L×**CW**3,0L   R5+=x4L×**CW**1,0L   **-**          R8=x4L×**CW**4,0L+P8     R6+=x4L×**CW**2,0L   R4+=x4L×**CW**0,0L   R2,R3\n\n  x4U\\|D8,D9     **-**          R9+=x4U×**CW**5,0U       R7+=x4U×**CW**3,0U   R5+=x4U×**CW**1,0U   **-**          R8+=x4U×**CW**4,0U       R6+=x4U×**CW**2,0U   R4+=x4U×**CW**0,0U   **-**\n\n  x5L\\|P10,P11   **-**          R11=x5L×**CW**5,0L+P11   R9+=x5L×**CW**3,0L   R7+=x5L×**CW**1,0L   **-**          R10=x5L×**CW**4,0L+P10   R8+=x5L×**CW**2,0L   R6+=x5L×**CW**0,0L   R4,R5\n\n  x5U\\|D10,D11   **-**          R11+=x5U×**CW**5,0U      R9+=x5U×**CW**3,0U   R7+=x5U×**CW**1,0U   **-**          R10+=x5U×**CW**4,0U      R8+=x5U×**CW**2,0U   R6+=x5U×**CW**0,0U   **-**\n  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f32sisoslic, 2x1x3x2 example sequence\n\nPn is *single-precision* input partial-sum *n* Dn is 0 under normal\ncircumstances (`$a14:15`) xnL is the 1st element (element 0) of a\n*f32v2* input vector xnU is the 2nd element (element 1) of a *f32v2*\ninput vector **CW**m,nL is the least significant 32-bits of common\nweight state **\\$CWEI**\\_*m*\\_*n* **CW**m,nU is the most significant\n32-bits of common weight state **\\$CWEI**\\_*m*\\_*n* Rn is the final\n*single-precision* result of successive multiply-accumulations that\nbegan with Pn\n\nenumFlags format:\n\n![f32sisoslic immediate\nformat](images/autogen/F32SLIC_ENUMFLAGS.*){.align-center}\n\n2 output channels are processed/produced.\n"),
        ("$FP_STS", "Floating-point status register.\n\n## Note\n\nThis register is explicitly reset on worker launch\n"),
        ("ldd16a64", "* `ldd16a64 $aDst0:Dst0+1, $mAddr0++, $mBase0, $mDelta0@`\n\nPost-incrementing 16-bit delta load with simultaneous 64-bit data load.\n\nDestination register-file: Combination of MRF and ARF\n\nEffective addresses:\n\n:   1.  A full-pointer value (`$m` register)\n    2.  Base address (`$m` register) plus 16-bit, unsigned address delta\n        (`$m` register)\n\nData format:\n\n:   1.  A 16-bit value (new delta-offset) written to the MRF delta\n        register.\n    2.  A 64-bit value written to the ARF destination register pair.\n\nAddress auto-increment:\n\n:   1.  The full-pointer source register value is incremented by 2\n        (bytes).\n"),
        ("$TAS", "**T**he **a**xpy **s**cale(s) (or **T**emporary **a**mp **s**torage).\nThe scalar value(s) used by the various \\*axp(b)y and \\*raxb\ninstructions (`f32v2axpy`, `f16v4mix` for example), (or temporary\nstorage for `f32sisoamp`, `f32sisoslic`,f16v8topk-instr-defn\nandf32v4topk-instr-defn)\n\n## Note\n\nThe value of this register is *undefined* at worker launch\n"),
        ("brz", "* `brz $mSrc0, zimm19`\n\nConditional branch to absolute address. Branch taken if and only if\nregister value **is 0**. Immediate provides word-addressed absolute\ndestination address.\n\n## Note\n\nThis instruction considers the floating-point *single-precision* value\n-0.0 to not be zero (+0.0)\n"),
        ("f16v4add", "* `f16v4add $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4add $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4add $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector element-wise addition.\n"),
        ("sort4x16hi", "* `sort4x16hi $mDst0, $mSrc0, $mSrc1`\n* `sort4x16hi $aDst0, $aSrc0, $aSrc1`\n* `sort4x16hi $aDst0, $aSrc0:BL, $aSrc1`\n\nPerform SIMD *sort* permutation on 4 x 16-bit values, across 2 source\nregisters, producing a 2 x 16-bit result.\n"),
        ("f32v2tof16", "* `f32v2tof16 $aDst0, $aSrc0:Src0+1`\n\n*Single-precision* floating-point pair to *f16* conversion\n"),
        ("$PRNG_0_0", "The least significant 32-bits of \\$PRNG_0.\n\n## Note\n\nThe value of this register is retained between worker exit and launch.\n"),
        ("sort4x32hi", "* `sort4x32hi $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\nPerform SIMD *sort* permutation on 4 x 32-bit values, across 2 source\nregister-pairs, producing a 2 x 32-bit result.\n"),
        ("not128", "* `not128 $aDst0:Dst0+3, $aSrc0:Src0+3`\n\n::: spec\nnot128_instruction_0xd694101ce6f45ebb\n\nCompute the bitwise logical NOT of a 128-bit ARF register-quad.\n"),
        ("$WORKER_BASE", "Worker context scratch space base address. Read alias of Supervisor\n**\\$WORKER\\<***ctxtId***\\>\\_BASE**.\n"),
        ("cmpult", "* `cmpult $mDst0, $mSrc0, $mSrc1`\n* `cmpult $mDst0, $mSrc0, zimm16`\n\n*Less than* comparison of two **unsigned** source values. Destination\nregister is set to 1 if the first source operand value is less than the\nsecond. Otherwise the destination register is set to 0. to 0. The\ncomparison operation is **unsigned**.\n"),
        ("f16v4absacc", "* `f16v4absacc $aSrc0:Src0+1`\n\n*Half-precision* 4-element vector accumulation of absolute values to\n*single-precision*.\n"),
        ("f16v8acc", "* `f16v8acc $aSrc0:Src0+3`\n\n*Half-precision* 8-element vector accumulation to *single-precision*.\n"),
        ("$PRNG_1_1", "The most significant 32-bits of \\$PRNG_1.\n\n## Note\n\nThe value of this register is retained between worker exit and launch.\n"),
        ("$a0:1", "`$a0` and `$a1` together as a 64-bit general purpose arithmetic register.\n"),
        ("roll8r", "* `roll8r $mDst0, $mSrc0, $mSrc1`\n\nPerform a SIMD *roll-right* permutation on the 8 x 8-bit values across 2\nsource registers.\n"),
        ("ldst64pace", "* `ldst64pace $aDst0:Dst0+1, $aSrc0:Src0+1, $mAddr0:Addr0+1+=, $mStride0, Strimm2x2`\n\nNaturally aligned 64-bit load and simultaneous 64-bit store, with dual\nindependent post-incrementing addresses.\n\nDestination register-file: ARF only\n\nSource register-file: ARF only\n\nEffective addresses:\n\n:   -   independent load and store addresses\n    -   provided directly from MRF as a register pair\n    -   lower register provides load address\n    -   store address is split across the upper-bits of both registers\n        (see `tapack`)\n\nData format:\n\n:   -   Load result is an unmodified 64-bit value stored in a naturally\n        aligned register pair.\n"),
        ("f32v2cmpgt", "* `f32v2cmpgt $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2cmpgt $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector greater-than test\n"),
        ("f16v4rmask", "* `f16v4rmask $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1`\n\n*Half-precision* floating-point vector random mask.\n\nThe result is a masked version of the input vector, with each element of\nthe input being individually masked with the probability specified by\nthe bottom 17-bits of the 2nd input operand:\n\n-   if \\$aSrc1\\[16\\] == 1, no masking is applied (the result is a copy\n    of the input vector)\n-   else if \\$aSrc1\\[16:0\\] == 0, the result is a zero vector\n-   otherwise each element is individually unmasked with probability\n    \\$frac{\\$aSrc1\\[15:0\\]}{65536}\\$\n\nPRNG is used by this instruction to generate 4 x 16-bit random values\nfrom the discrete uniform distribution.\n"),
        ("f32v2cmpne", "* `f32v2cmpne $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2cmpne $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector inequality test\n"),
        ("f16v4acc", "* `f16v4acc $aSrc0:Src0+1`\n\n*Half-precision* 4-element vector accumulation to *single-precision*.\n"),
        ("f16v2cmpne", "* `f16v2cmpne $aDst0, $aSrc0, $aSrc1`\n* `f16v2cmpne $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2cmpne $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector equality test\n"),
        ("f32v4tof16", "* `f32v4tof16 $aDst0:Dst0+1, $aSrc0:Src0+3`\n\n*Single-precision* floating-point 4-element vector to *f16* 4-element\nvector conversion.\n"),
        ("$TDI_STS", "Tile Debug Interface status register.\n"),
        ("$VERTEX_BASE", "Vertex data structure pointer. Initialised on behalf of a Worker context\nby the Supervisor via or . This register can also be read through an MRF\nalias.\n"),
        ("$INCOMING_SINIT", "Sync initialisation value for `$INCOMING_DELTA`. Execution of the `sync`\ninstruction causes the value of this register to be copied into\n`$INCOMING_DELTA`.\n"),
        ("$m11", "`$m11` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("f32sufromui", "* `f32sufromui $aDst0, $aSrc0`\n\nSymmetric, unbiased conversion from an unsigned 32-bit integer to\n*single-precision* floating-point.\n\nThe *single-precision* result lies within the range \\$\\[-frac{1}{2},\nfrac{1}{2}\\]\\$ but can never be exactly 0. The result will also have a\nmagnitude of at least \\$frac{1}{2\\^{33}}\\$ (and therefore results will\nnever be inside the denormalised number range for *single-precision*).\n\nNote that this instruction can be combined with `urand32`/`urand64` to\nproduce a random, uniformly distributed floating-point value.\n"),
        ("$INCOMING_BASE", "*Tile Memory* base address for internal exchange incoming messages. The\neffective address for the next internal exchange incoming message is\n`$INCOMING_BASE` + `$INCOMING_DELTA`.\n"),
        ("st32", "* `st32 $aSrc0, $mBase0, $mDelta0, $mOffset0`\n* `st32 $mSrc0, $mBase0, $mDelta0, zimm12`\n* `st32 $aSrc0, $mBase0, $mDelta0, zimm12`\n\nStore a single 32-bit register value toTile Memory.\n\nSource register-file: MRF or ARF\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n"),
        ("$TDI_CLR", "Tile Debug Interface error clear register\n"),
        ("f16v4min", "* `f16v4min $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector element-wise minimum\n"),
        ("ldb16b16", "* `ldb16b16 $aDst0:Dst0+1, $mBase0, $mDelta0++, $mMiniD0&gt;&gt;`\n\nBroadcast 16-bit load from base + 16-bit delta-offset with 2nd broadcast\n16-bit load from base plus 2nd 16-bit delta-offset.\n\nDestination register-file: ARF only\n\nEffective addresses:\n\n:   -   2 load addresses provided directly from MRF as a common base\n        register plus independent 16-bit delta-offsets (packed into a\n        single MRF register)\n\nData format:\n\n:   -   Results are 2 x *f16v2* values stored in a naturally aligned\n        register pair. Each *f16v2* vector is created from a broadcast\n        operation on a single 16-bit value loaded from *Tile Memory*.\n\nAddress auto-increment:\n\n:   -   The two 16-bit delta-offsets are post-incremented independently:\n        -   One is incremented by 2 (bytes)\n        -   The other is incremented according to the 4-bit mini-delta\n            value in the lsbs of the 4th operand.\n    -   The mini-delta operand is also right-shifted by 4.\n"),
        ("setzi", "* `setzi $mDst0, zimm20`\n* `setzi $aDst0, zimm20`\n\nSet register to *zero extended* 20-bit immediate value.\n"),
        ("cmpeq", "* `cmpeq $mDst0, $mSrc0, $mSrc1`\n* `cmpeq $mDst0, $mSrc0, zimm16`\n* `cmpeq $mDst0, $mSrc0, simm16`\n\n*Equality* comparison of two source values. The destination is set to 1\nif the two source operands are equal. Otherwise the destination register\nis set to 0.\n"),
        ("ld64putcs", "* `ld64putcs zimm8`\n\nLoad a naturally-aligned 64-bit quantity and write the value to the\ncommon compute configuration space. The load address is provided by\n`$CCCSLOAD`, which is automatically post-incremented by 8.\n"),
        ("f16v2sigm", "* `f16v2sigm $aDst0, $aSrc0`\n\n\n"),
        ("f32min", "* `f32min $aDst0, $aSrc0, $aSrc1`\n\nDetermine the minimum floating-point value from two register source\nvalues.\n"),
        ("f32absmax", "* `f32absmax $aDst0, $aSrc0, $aSrc1`\n\nDetermine the maximum floating-point value from two absolute register\nsource values.\n"),
        ("f32v2aop", "* `f32v2aop $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\n*Single-precision* 2-element vector outer product with accumulation to\n*single-precision*.\n"),
        ("f16v2cmpge", "* `f16v2cmpge $aDst0, $aSrc0, $aSrc1`\n* `f16v2cmpge $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2cmpge $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector greater-than-or-equal-to test\n"),
        ("$INCOMING_DELTA", "Auto-incrementingTile Memory delta offset for internal exchange incoming\nmessages. The address is incremented by 4-bytes for each new *word*\nreceived. The effective address for the next internal exchange incoming\nmessage is `$INCOMING_BASE` + `$INCOMING_DELTA`. An explicit write to\nthis register from `put` always wins over an auto-increment.\n"),
        ("f32ln", "* `f32ln $aDst0, $aSrc0`\n\n\n"),
        ("$OUTGOING_BASE", "Common base address for send instructions. Used by all send\ninstructions.\n"),
        ("$SCOUNT_U", "[Tile]{.title-ref} cycle counter value. Upper 32-bits. An explicit write\nvia `put` always wins over hardware clock tick.\n"),
        ("$a1", "`$a1` general purpose arithmetic register.\n"),
        ("$TDI_CTL", "Target Debug Interface control register.\n"),
        ("$PRNG_SEED", "Writes to this register cause the following assignments to the \\$PRNG\nstate:\n\n-   `$PRNG_0_0` =value\n-   `$PRNG_0_1` = \\~value\n-   `$PRNG_1_0` = (value \\<\\< 13) \\| (\\~value \\>\\> 19)\n-   `$PRNG_1_1` = (\\~value \\<\\< 13) \\| (value \\>\\> 19)\n\nReads return 0.\n"),
        ("ld128putcs", "* `ld128putcs zimm8`\n\nLoad a naturally aligned 128-bit quantity, from a memory region with an\n*interleave factor* of at least 2 and write the value to the common\ncompute configuration space. The load address is provided by\n`$CCCSLOAD`, which is automatically post-incremented by 16.\n"),
        ("max", "* `max $mDst0, $mSrc0, $mSrc1`\n* `max $mDst0, $mSrc0, zimm16`\n* `max $mDst0, $mSrc0, simm16`\n\nSelect the maximum of 1 signed register source value and 1 signed\nregister or *sign extended*/*zero extended*/*zero tailed* immediate\nvalue.\n"),
        ("$OUTGOING_DELTA", "Outgoing message address delta for send instructions. Used and modified\nby a subset of send instructions.\n"),
        ("$a4:5", "`$a4` and `$a5` together as a 64-bit general purpose arithmetic register.\n"),
        ("f32v2mac", "* `f32v2mac $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector multiply and 32-bit accumulate\n"),
        ("$DBG_ECSR", "CSR alias. See `$DBG_ECSR`. Note that a write from a `put` wins over a\nsimultaneous write via this alias.\n"),
        ("$m0", "`$m0` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("ld32", "* `ld32 $mDst0, $mBase0, $mDelta0, $mOff0`\n* `ld32 $aDst0, $mBase0, $mDelta0, $mOff0`\n* `ld32 $mDst0, $mBase0, $mDelta0, zimm12`\n* `ld32 $aDst0, $mBase0, $mDelta0, zimm12`\n\nLoad a single, naturally aligned 32-bit value fromTile Memory.\n\nDestination register-file: MRF or ARF\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is an unmodified 32-bit value.\n"),
        ("f16v2absadd", "* `f16v2absadd $aDst0, $aSrc0, $aSrc1`\n\n*Half-precision* 2-element vector element-wise addition of absolute\nvalues.\n"),
        ("urand32", "* `urand32 $aDst0`\n\nUniform distribution, 32-bit random integer.\n"),
        ("swap8", "* `swap8 $mDst0, $mSrc0`\n\nPerform *swap* SIMD permutation on 4 x 8-bit values.\n"),
        ("$a2", "`$a2` general purpose arithmetic register.\n"),
        ("popc", "* `popc $mDst0, $mSrc0`\n\nEstablishes the number of set bits in a 32-bit register source value.\n"),
        ("f16v2maxc", "* `f16v2maxc $aDst0, $aSrc0`\n\n*Half-precision* 2-element vector lateral maximum.\n"),
        ("shuf8x8lo", "* `shuf8x8lo $mDst0, $mSrc0, $mSrc1`\n\nPerform SIMD *shuffle* permutation on 8 x 8-bit values, across 2 source\nregisters, returning the lower *word* of the result. See [shuf8x8hi]()\nfor upper *word*.\n"),
        ("f16v2add", "* `f16v2add $aDst0, $aSrc0, $aSrc1`\n* `f16v2add $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2add $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector add on two register source\nvalues.\n"),
        ("$ANS_DCOUNT", "Automatic non-participatory sync down-counter. VALUE is decremented for\neach sync-acknowledge received in response to the automatic assertion of\nthe sync request signal.\n"),
        ("lds16", "* `lds16 $mDst0, $mBase0, $mDelta0, $mOff0`\n* `lds16 $mDst0, $mBase0, $mDelta0, zimm12`\n\nLoad and sign-extend a single, naturally aligned 16-bit quantity\nfromTile Memory.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is a 32-bit value formed by sign-extending the 16-bit\n        data value.\n"),
        ("exitz", "* `exitz $mSrc0`\n\nTerminate current execution of a *Worker* thread and return a Boolean\nexit status to the *Supervisor* thread. This instruction passes control\nfrom a *Worker* thread to the *Supervisor* thread. The currently\nallocated thread execution slot is returned to the *Supervisor*, which\nmay reassign the execution slot to another task.\n\n## Note\n\nThis instruction considers the floating-point *single-precision* value\n-0.0 to not be zero (+0.0)\n"),
        ("$DBG_RBRK_VERT", "Used when requesting a Vertex-Matched Retirement BREAK (see\n`$DBG_RBRK`). In this case, the Retirement BREAK is conditional on a\n*Worker* context\\'s `$VERTEX_BASE` register matching .\n"),
        ("f16v2cmac", "* `f16v2cmac $aSrc0, $aSrc1`\n\n*Half-precision* floating-point vector element-wise multiply with\n*single-precision* lateral sum and accumulate.\n"),
        ("shuf8x8hi", "* `shuf8x8hi $mDst0, $mSrc0, $mSrc1`\n\nPerform SIMD *shuffle* permutation on 8 x 8-bit values, across 2 source\nregisters, returning the upper *word* of the result. See [shuf8x8lo]()\nfor lower *word*.\n"),
        ("tapack", "* `tapack $mDst0:Dst0+1, $mAddr0, $mAddr1, $mAddr2`\n\nConvert 3 absolute addresses to the triple-packed address format.\n"),
        ("$CCCSLOAD", "Post-incrementing load address for `ld64putcs` and `ld128putcs`.\n"),
        ("$REPEAT_FIRST", "The address of the initial *Execution Bundle* of the current (previous\nif not currently executing a repeat block) `rpt` repeat-body.\n\n## Note\n\nThe value of this register is *undefined* at worker launch\n"),
        ("f32sisoamp", "* `f32sisoamp $aDst0:Dst0+1, $aSrc0, $aSrc1:Src1+1, enumFlags`\n\n*Single-precision* floating-point **a**ccumulating **m**atrix-vector\n**p**roduct. Input partial-sums and result values are\n*single-precision*.\n\nenumFlags format:\n\n![f32sisoamp immediate\nformat](images/autogen/F32AMP_ENUMFLAGS.*){.align-center}\n\n8 output channels are processed/produced.\n"),
        ("$m1", "`$m1` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("ldz16", "* `ldz16 $mDst0, $mBase0, $mDelta0, $mOff0`\n* `ldz16 $mDst0, $mBase0, $mDelta0, zimm12`\n\nLoad and zero-extend a single, naturally aligned 16-bit quantity\nfromTile Memory.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is a 32-bit value formed by zero-extending the 16-bit\n        data value.\n"),
        ("f32v2sub", "* `f32v2sub $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2sub $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector subtraction\n"),
        ("exitnz", "* `exitnz $mSrc0`\n\nTerminate current execution of a *Worker* thread and return a Boolean\nexit status to the *Supervisor* thread. This instruction passes control\nfrom a *Worker* thread to the *Supervisor* thread. The currently\nallocated thread execution slot is returned to the *Supervisor*, which\nmay reassign the execution slot to another task.\n\n## Note\n\nThis instruction considers the floating-point *single-precision* value\n-0.0 to not be zero (+0.0)\n"),
        ("f32sisov2slic", "* `f32sisov2slic $aDst0:Dst0+1, $aSrc0, $aSrc1:Src1+1, enumFlags`\n\n*Single-precision* floating-point **sli**m **c**onvolution. Input\npartial-sums are *single-precision*. Results are *single-precision*.\n\n4 output channels are processed/produced\n"),
        ("urand64", "* `urand64 $aDst0:Dst0+1`\n\nUniform distribution, 64-bit random integer.\n"),
        ("ld64a32pace", "* `ld64a32pace $aDst0:Dst0+1, $aDst1, $mAddr0:Addr0+1+=, $mStride0, Strimm2x2`\n\nNaturally aligned dual 64/32-bit load, with dual independent\npost-incrementing addresses.\n\nDestination register-file: ARF only\n\nEffective addresses:\n\n:   -   2 independent load addresses\n    -   provided directly from MRF as a register pair\n    -   lower register provides 1st load address\n    -   upper register provides 2nd load address\n\nData format:\n\n:   -   Results are:\n        -   1 unmodified 64-bit value stored in a naturally aligned\n            register pair\n        -   1 unmodified 32-bit value stored in a single ARF register\n\nNote that a TEXCPT_INVALID_OP exception will occur if the two\ndestination register pairs are not distinct.\n"),
        ("$a5", "`$a5` general purpose arithmetic register.\n"),
        ("f32v2add", "* `f32v2add $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2add $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector add\n"),
        ("f16v2absmax", "* `f16v2absmax $aDst0, $aSrc1, $aSrc0`\n\n*Half-precision* floating-point vector max of absolute values\n"),
        ("f16v2sub", "* `f16v2sub $aDst0, $aSrc0, $aSrc1`\n* `f16v2sub $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2sub $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector subtract\n"),
        ("f32v2class", "* `f32v2class $aDst0, $aSrc0:Src0+1`\n\n*Single-precision* floating-point vector classifier. IEEE 754-2008:\n5.7.2\n"),
        ("f32cmpgt", "* `f32cmpgt $aDst0, $aSrc0, $aSrc1`\n\nTest if a floating-point number is greater than a second floating-point\nnumber. If so, the destination register is set to , otherwise it is set\nto .\n"),
        ("$a6:7", "`$a6` and `$a7` together as a 64-bit general purpose arithmetic register.\n"),
        ("$WORKER{0}_BASE", "Worker thread {} scratch space base address. Read/write alias of\n`$WORKER_BASE`.\n"),
        ("f32cmpeq", "* `f32cmpeq $aDst0, $aSrc0, $aSrc1`\n\nTest if two floating-point numbers are equal. If so, the destination\nregister is set to , otherwise it is set to .\n"),
        ("$FP_CLR", "Floating-point exception/state clear. Write 0b1 to clear the specified\nfloating-point exception flag or internal state. Reads always return 0.\n"),
        ("$m14", "`$m14` register. Read only. Returns an implementation-specific value.\n"),
        ("ldd16a32", "* `ldd16a32 $aDst0, $mAddr0++, $mBase0, $mDelta0@`\n\nPost-incrementing 16-bit delta load with simultaneous 32-bit data load.\n\nDestination register-file: Combination of MRF and ARF\n\nEffective addresses:\n\n:   1.  A full-pointer value (`$m` register)\n    2.  Base address (`$m` register) plus 16-bit, unsigned address delta\n        (`$m` register)\n\nData format:\n\n:   1.  A 16-bit value (new delta-offset) written to the MRF delta\n        register.\n    2.  A 32-bit value written to the ARF destination register.\n\nAddress auto-increment:\n\n:   1.  The full-pointer source register value is incremented by 2\n        (bytes).\n"),
        ("$COUNT_L", "[Tile]{.title-ref} cycle counter value. Lower 32-bits\n"),
        ("lds16step", "* `lds16step $mDst0, $mBase0, $mDelta0+=, simm8`\n* `lds16step $mDst0, $mBase0, $mDelta0+=, $mStride0`\n\nSign-extending, naturally aligned 16-bit load with scaled\npost-incrementing address.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is a 32-bit value formed by sign-extending the 16-bit\n        data value.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("f16v4hihoamp", "* `f16v4hihoamp $aDst0, $aSrc0:Src0+1, $aSrc1, enumFlags`\n\n*Half-precision* floating-point vector accumulating matrix-vector\nproduct. Input partial-sum and result values are *half-precision*.\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1     \\$AACC\\[14\\]            \\$AACC\\[12\\]            \\$AACC\\[10\\]            \\$AACC\\[8\\]             \\$AACC\\[6\\]             \\$AACC\\[4\\]             \\$AACC\\[2\\]             \\$AACC\\[0\\]             \\$aDst0\n  -------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ---------\n  0[^1]\\|P0,P1   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**\n\n  0\\|P2,P3       **-**                   **-**                   **-**                   \\[**WARM-UP**           **PERIOD**\\]            **-**                   **-**                   **-**                   **-**\n\n  0\\|P4,P5       **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**\n\n  0\\| P6,P7      **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**\n\n  x0\\|P8,P9      R7=x0.**CW**7,0+P7      R6=x0.**CW**6,0+P6      R5=x0.**CW**5,0+P5      R4=x0.**CW**4,0+P4      R3=x0.**CW**3,0+P3      R2=x0.**CW**2,0+P2      R1=x0.**CW**1,0+P1      R0=x0.**CW**0,0+P0      **-**\n\n  x1\\|P10,P11    R7+=x1.**CW**7,1        R6+=x1.**CW**6,1        R5+=x1.**CW**5,1        R4+=x1.**CW**4,1        R3+=x1.**CW**3,1        R2+=x1.**CW**2,1        R1+=x1.**CW**1,1        R0+=x1.**CW**0,1        **-**\n\n  x2\\|P12,P13    R7+=x2.**CW**7,2        R6+=x2.**CW**6,2        R5+=x2.**CW**5,2        R4+=x2.**CW**4,2        R3+=x2.**CW**3,2        R2+=x2.**CW**2,2        R1+=x2.**CW**1,2        R0+=x2.**CW**0,2        **-**\n\n  x3\\|P14,P15    R7+=x3.**CW**7,3        R6+=x3.**CW**6,3        R5+=x3.**CW**5,3        R4+=x3.**CW**4,3        R3+=x3.**CW**3,3        R2+=x3.**CW**2,3        R1+=x3.**CW**1,3        R0+=x3.**CW**0,3        **-**\n\n  x4\\|P16,P17    R15=x4.**CW**7,0+P15    R14=x4.**CW**6,0+P14    R13=x4.**CW**5,0+P13    R12=x4.**CW**4,0+P12    R11=x4.**CW**3,0+P11    R10=x4.**CW**2,0+P10    R9=x4.**CW**1,0+P9      R8=x4.**CW**0,0+P8      R0,R1\n\n  x5\\|P18,P19    R15+=x5.**CW**7,1       R14+=x5.**CW**6,1       R13+=x5.**CW**5,1       R12+=x5.**CW**4,1       R11+=x5.**CW**3,1       R10+=x5.**CW**2,1       R9+=x5.**CW**1,1        R8+=x5.**CW**0,1        R2,R3\n\n  x6\\|P20,P21    R15+=x6.**CW**7,2       R14+=x6.**CW**6,2       R13+=x6.**CW**5,2       R12+=x6.**CW**4,2       R11+=x6.**CW**3,2       R10+=x6.**CW**2,2       R9+=x6.**CW**1,2        R8+=x6.**CW**0,2        R4,R5\n\n  x7\\|P22,P23    R15+=x7.**CW**7,3       R14+=x7.**CW**6,3       R13+=x7.**CW**5,3       R12+=x7.**CW**4,3       R11+=x7.**CW**3,3       R10+=x7.**CW**2,3       R9+=x7.**CW**1,3        R8+=x7.**CW**0,3        R6,R7\n\n  x8\\|P24,P25    R23=x8.**CW**7,0+P23    R22=x8.**CW**6,0+P22    R21=x8.**CW**5,0+P21    R20=x8.**CW**4,0+P20    R19=x8.**CW**3,0+P19    R18=x8.**CW**2,0+P18    R17=x8.**CW**1,0+P17    R16=x8.**CW**0,0+P16    R8,R9\n\n  x9\\|P26,P27    R23+=x9.**CW**7,1       R22+=x9.**CW**6,1       R21+=x9.**CW**5,1       R20+=x9.**CW**4,1       R19+=x9.**CW**3,1       R18+=x9.**CW**2,1       R17+=x9.**CW**1,1       R16+=x9.**CW**0,1       R10,R11\n\n  x10\\|P28,P29   R23+=x10.**CW**7,2      R22+=x10.**CW**6,2      R21+=x10.**CW**5,2      R20+=x10.**CW**4,2      R19+=x10.**CW**3,2      R18+=x10.**CW**2,2      R17+=x10.**CW**1,2      R16+=x10.**CW**0,2      R12,R13\n\n  x11\\|P30,P31   R23+=x11.**CW**7,3      R22+=x11.**CW**6,3      R21+=x11.**CW**5,3      R20+=x11.**CW**4,3      R19+=x11.**CW**3,3      R18+=x11.**CW**2,3      R17+=x11.**CW**1,3      R16+=x11.**CW**0,3      R14,R15\n\n  x12\\|P32,P33   R31=x12.**CW**7,0+P31   R30=x12.**CW**6,0+P30   R29=x12.**CW**5,0+P29   R28=x12.**CW**4,0+P28   R27=x12.**CW**3,0+P27   R26=x12.**CW**2,0+P26   R25=x12.**CW**1,0+P25   R24=x12.**CW**0,0+P24   R16,R17\n  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f16v4hihoamp 8x1x1x16 example sequence\n\nPn is *half-precision* input partial-sum *n* xn is an *f16v4* input\nvector **CW**m,n is the common weight state **\\$CWEI**\\_*m*\\_*n* Rn is\nthe final *half-precision* result of successive dot-product\naccumulations that began with Pn\n\n[^1]: 0 input used to fill AMP pipeline during warm-up period\n"),
        ("f32cmple", "* `f32cmple $aDst0, $aSrc0, $aSrc1`\n\nTest if a floating-point number is less than or equal to a second\nfloating-point number. If so, the destination register is set to ,\notherwise it is set to .\n"),
        ("f32oox", "* `f32oox $aDst0, $aSrc0`\n\n*Single-precision* reciprocal.\n"),
        ("f16v4sub", "* `f16v4sub $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4sub $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4sub $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* floating-point 4-element vector subtraction\n"),
        ("min", "* `min $mDst0, $mSrc0, $mSrc1`\n* `min $mDst0, $mSrc0, zimm16`\n* `min $mDst0, $mSrc0, simm16`\n\nSelect the minimum of 2 signed integer values. Immediates may be *sign\nextended*, *zero extended* or *zero tailed*.\n"),
        ("f32v2cmpeq", "* `f32v2cmpeq $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2cmpeq $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector equality test\n"),
        ("$m3", "`$m3` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("cmpslt", "* `cmpslt $mDst0, $mSrc0, $mSrc1`\n* `cmpslt $mDst0, $mSrc0, simm16`\n\n*Less than* comparison of two **signed** source values. Destination\nregister is set to 1 if the first source operand is less than the\nsecond. Otherwise the destination register is set to 0. The comparison\noperation is **signed**.\n"),
        ("f32v2max", "* `f32v2max $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector element-wise max\n"),
        ("$a6", "`$a6` general purpose arithmetic register.\n"),
        ("lds8", "* `lds8 $mDst0, $mBase0, $mDelta0, $mOff0`\n* `lds8 $mDst0, $mBase0, $mDelta0, zimm12`\n\nLoad and sign-extend a single, 8-bit quantity fromTile Memory.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is a 32-bit value formed by sign-extending the 8-bit\n        loaded data value.\n"),
        ("f16v4absmax", "* `f16v4absmax $aDst0:Dst0+1, $aSrc1:Src1+1, $aSrc0:Src0+1`\n\n*Half-precision* 4-element vector element-wise max of absolute values\n"),
        ("f16v4cmpge", "* `f16v4cmpge $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4cmpge $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4cmpge $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector greater-than or equal-to test\n"),
        ("put", "* `put zimm8, $mSrc0`\n\nWrite to a control register. See control_and_status_registers.\n"),
        ("cms", "* `cms $mDst0, $mSrc0`\n\nEstablishes the number of higher order bits that match the sign-bit (bit\n31). Result is always in the range \\[0..31\\].\n"),
        ("f16v4max", "* `f16v4max $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector element-wise max\n"),
        ("ldd16v2a32", "* `ldd16v2a32 $aDst0, $mAddr0++, $mBase0, $mDelta0@`\n\nPost-incrementing load of dense 16-bit delta-pair plus a sparse 32-bit\ndata value.\n\nDestination register-file: ARF only\n\nEffective addresses:\n\n:   1.  A full-pointer register value (notionally a pointer into an\n        array of 16-bit deltas)\n    2.  A base address register value added to a 16-bit delta-offset\n        located in the msbs of a third source register value.\n\nData format:\n\n:   -   Results are:\n        -   A new pair of 16-bit deltas\n        -   A naturally aligned 32-bit data value, written to the\n            destination register\n\nAddress auto-increment:\n\n:   -   The full pointer register is post-incremented by 4 (bytes)\n"),
        ("f16v4gacc", "* `f16v4gacc $aDst0:Dst0+1`\n\nGet accumulators.\n\nRead 4 internal accumulator values as a *half-precision* vector.\n"),
        ("$azero", "Alias for `$a15`. This register is read-only and always returns 0.\n"),
        ("f32v2rmask", "* `f32v2rmask $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1`\n\n*Single-precision* floating-point vector random mask.\n\nThe result is a masked version of the input vector, with each element of\nthe input being individually masked with the probability specified by\nthe bottom 17-bits of the 2nd input operand:\n\n-   if \\$aSrc1\\[16\\] == 1, no masking is applied (the result is a copy\n    of the input vector)\n-   else if \\$aSrc1\\[16:0\\] == 0, the result is a zero vector\n-   otherwise each element is individually unmasked with probability\n    \\$frac{\\$aSrc1\\[15:0\\]}{65536}\\$\n\nPRNG is used by this instruction to generate 2 x 16-bit random values\nfrom the discrete uniform distribution.\n"),
        ("uput", "* `uput zimm8, $aSrc0`\n\nWrite to a control register in the upper CSR address space. See\nWorker-csrs\n"),
        ("f16v4sihoslic", "* `f16v4sihoslic $aDst0, $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\n*Half-precision* floating-point vector slim convolution. Input\npartial-sums are *single-precision*. Results are *half-precision*\n"),
        ("cmpne", "* `cmpne $mDst0, $mSrc0, $mSrc1`\n\n*Inequality* comparison of two source values. The destination is set to\n0 if the two source operands are equal. Otherwise the destination\nregister is set to 1.\n"),
        ("f32sigm", "* `f32sigm $aDst0, $aSrc0`\n\n\n"),
        ("f16v4hihov4slic", "* `f16v4hihov4slic $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\n*Half-precision* floating-point slim convolution. Input and result\npartial-sums are 4 x *half-precision* values.\n"),
        ("ldb16step", "* `ldb16step $aDst0, $mBase0, $mDelta0+=, simm8`\n* `ldb16step $aDst0, $mBase0, $mDelta0+=, $mStride0`\n\nNaturally aligned 16-bit load and broadcast with scaled\npost-incrementing address.\n\nDestination register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is a 32-bit value formed by broadcasting (duplicating)\n        the 16-bit data value.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("$m2", "`$m2` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("st64", "* `st64 $aSrc0:Src0+1, $mBase0, $mDelta0, $mOffset0`\n* `st64 $aSrc0:Src0+1, $mBase0, $mDelta0, zimm12`\n\nStore a single 64-bit value, from a naturally aligned register pair\ntoTile Memory.\n\nSource register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n"),
        ("f16v2cmpgt", "* `f16v2cmpgt $aDst0, $aSrc0, $aSrc1`\n* `f16v2cmpgt $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2cmpgt $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector greater-than test\n"),
        ("$mvertex_base", "The Vertex Base Register (an alias for `$m13`). Initialised on behalf of a Worker context by the Supervisor via `run` or `runall`.\n"),
        ("$m15", "`$m15` register. Read only. Always reads 0. Also available through the `$mzero` alias.\n"),
        ("f16v4absadd", "* `f16v4absadd $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector element-wise addition of absolute\nvalues.\n"),
        ("$TILE_ID", "Unique identifier for thisTile instance (logicalTile ID).\n"),
        ("clz", "* `clz $mDst0, $mSrc0`\n\nEstablishes the number of higher order bits that are zero. An unsigned\ninterpretation of the source value can be stored in (32 - result) bits\nwithout loss.\n"),
        ("f16v4stacc", "* `f16v4stacc $aDst0:Dst0+1, enumFlags`\n\nSort/shuffle (permute) through accumulators.\n\n-   Perform \\$AACC state propagation as specified by the immediate.\n-   The destination register pair is written with 64-bits of result\n    data from a combination of \\$AACC registers. The precise\n    combination is specified by the immediate.\n"),
        ("stm32", "* `stm32 $mSrc0, $mBase0, $mOffset0`\n\nStore a single 32-bit MRF register value toTile Memory.\n\nSource register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned scaled offset (`$m` register)\n"),
        ("roll16", "* `roll16 $mDst0, $mSrc0, $mSrc1`\n* `roll16 $aDst0, $aSrc0, $aSrc1`\n\nPerform a SIMD *roll* permutation on the 4 x 16-bit values across 2\nsource registers. Equivalent to a SIMD *roll* operation on 8 x 8-bit\nvalues.\n"),
        ("sub", "* `sub $mDst0, $mSrc1, $mSrc0`\n* `sub $mDst0, zimm16, $mSrc0`\n* `sub $mDst0, simm16, $mSrc0`\n\nInteger subtraction of 1 register value from another or from immediate.\nImmediates may be *sign extended*, *zero extended* or *zero tailed* to\n*word* width.\n"),
        ("and", "* `and $mDst0, $mSrc0, $mSrc1`\n* `and $mDst0, $mSrc0, zimm12`\n* `and $aDst0, $aSrc0, $aSrc1`\n* `and $aDst0, $aSrc0, zimm12`\n* `and $aDst0, $aSrc0, immz12`\n\nBitwise logical AND of two source register values, or 1 source register\nand 1 *zero extended*/*zero tailed* immediate.\n"),
        ("f16v4sisoamp", "* `f16v4sisoamp $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\n*f16* floating-point accumulating matrix-vector product. Input and\nresult partial-sums are 2 x *single-precision* values.\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1     \\$AACC\\[14\\]            \\$AACC\\[12\\]            \\$AACC\\[10\\]            \\$AACC\\[8\\]             \\$AACC\\[6\\]             \\$AACC\\[4\\]             \\$AACC\\[2\\]             \\$AACC\\[0\\]             \\$aDst0\n  -------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ---------\n  0[^1]\\|P0,P1   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**\n\n  0\\|P2,P3       **-**                   **-**                   **-**                   \\[**WARM-UP**           **PERIOD**\\]            **-**                   **-**                   **-**                   **-**\n\n  0\\|P4,P5       **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**\n\n  0\\| P6,P7      **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**\n\n  x0\\|P8,P9      R7=x0.**CW**7,0+P7      R6=x0.**CW**6,0+P6      R5=x0.**CW**5,0+P5      R4=x0.**CW**4,0+P4      R3=x0.**CW**3,0+P3      R2=x0.**CW**2,0+P2      R1=x0.**CW**1,0+P1      R0=x0.**CW**0,0+P0      **-**\n\n  x1\\|P10,P11    R7+=x1.**CW**7,1        R6+=x1.**CW**6,1        R5+=x1.**CW**5,1        R4+=x1.**CW**4,1        R3+=x1.**CW**3,1        R2+=x1.**CW**2,1        R1+=x1.**CW**1,1        R0+=x1.**CW**0,1        **-**\n\n  x2\\|P12,P13    R7+=x2.**CW**7,2        R6+=x2.**CW**6,2        R5+=x2.**CW**5,2        R4+=x2.**CW**4,2        R3+=x2.**CW**3,2        R2+=x2.**CW**2,2        R1+=x2.**CW**1,2        R0+=x2.**CW**0,2        **-**\n\n  x3\\|P14,P15    R7+=x3.**CW**7,3        R6+=x3.**CW**6,3        R5+=x3.**CW**5,3        R4+=x3.**CW**4,3        R3+=x3.**CW**3,3        R2+=x3.**CW**2,3        R1+=x3.**CW**1,3        R0+=x3.**CW**0,3        **-**\n\n  x4\\|P16,P17    R15=x4.**CW**7,0+P15    R14=x4.**CW**6,0+P14    R13=x4.**CW**5,0+P13    R12=x4.**CW**4,0+P12    R11=x4.**CW**3,0+P11    R10=x4.**CW**2,0+P10    R9=x4.**CW**1,0+P9      R8=x4.**CW**0,0+P8      R0,R1\n\n  x5\\|P18,P19    R15+=x5.**CW**7,1       R14+=x5.**CW**6,1       R13+=x5.**CW**5,1       R12+=x5.**CW**4,1       R11+=x5.**CW**3,1       R10+=x5.**CW**2,1       R9+=x5.**CW**1,1        R8+=x5.**CW**0,1        R2,R3\n\n  x6\\|P20,P21    R15+=x6.**CW**7,2       R14+=x6.**CW**6,2       R13+=x6.**CW**5,2       R12+=x6.**CW**4,2       R11+=x6.**CW**3,2       R10+=x6.**CW**2,2       R9+=x6.**CW**1,2        R8+=x6.**CW**0,2        R4,R5\n\n  x7\\|P22,P23    R15+=x7.**CW**7,3       R14+=x7.**CW**6,3       R13+=x7.**CW**5,3       R12+=x7.**CW**4,3       R11+=x7.**CW**3,3       R10+=x7.**CW**2,3       R9+=x7.**CW**1,3        R8+=x7.**CW**0,3        R6,R7\n\n  x8\\|P24,P25    R23=x8.**CW**7,0+P23    R22=x8.**CW**6,0+P22    R21=x8.**CW**5,0+P21    R20=x8.**CW**4,0+P20    R19=x8.**CW**3,0+P19    R18=x8.**CW**2,0+P18    R17=x8.**CW**1,0+P17    R16=x8.**CW**0,0+P16    R8,R9\n\n  x9\\|P26,P27    R23+=x9.**CW**7,1       R22+=x9.**CW**6,1       R21+=x9.**CW**5,1       R20+=x9.**CW**4,1       R19+=x9.**CW**3,1       R18+=x9.**CW**2,1       R17+=x9.**CW**1,1       R16+=x9.**CW**0,1       R10,R11\n\n  x10\\|P28,P29   R23+=x10.**CW**7,2      R22+=x10.**CW**6,2      R21+=x10.**CW**5,2      R20+=x10.**CW**4,2      R19+=x10.**CW**3,2      R18+=x10.**CW**2,2      R17+=x10.**CW**1,2      R16+=x10.**CW**0,2      R12,R13\n\n  x11\\|P30,P31   R23+=x11.**CW**7,3      R22+=x11.**CW**6,3      R21+=x11.**CW**5,3      R20+=x11.**CW**4,3      R19+=x11.**CW**3,3      R18+=x11.**CW**2,3      R17+=x11.**CW**1,3      R16+=x11.**CW**0,3      R14,R15\n\n  x12\\|P32,P33   R31=x12.**CW**7,0+P31   R30=x12.**CW**6,0+P30   R29=x12.**CW**5,0+P29   R28=x12.**CW**4,0+P28   R27=x12.**CW**3,0+P27   R26=x12.**CW**2,0+P26   R25=x12.**CW**1,0+P25   R24=x12.**CW**0,0+P24   R16,R17\n  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f16v4sisoamp 8x1x1x16 example sequence\n\nPn is *single-precision* input partial-sum *n* xn is an *f16v4* input\nvector **CW**m,n is the common weight state **\\$CWEI**\\_*m*\\_*n* Rn is\nthe final *single-precision* result of successive dot-product\naccumulations that began with Pn\n\nenumFlags format:\n\n![f16v4sisoamp immediate\nformat](images/autogen/F16AMP_ENUMFLAGS.*){.align-center}\n\n8 output channels are processed/produced.\n\n[^1]: 0 input used to fill AMP pipeline during warm-up period\n"),
        ("f16v2sufromui", "* `f16v2sufromui $aDst0, $aSrc0`\n\nSymmetric, unbiased conversion from 2-element vector of unsigned 16-bit\nintegers to 2-element *half-precision* vector.\n\nEach of the *half-precision* results lies within the range\n\\$\\[-frac{1}{2}, frac{1}{2}\\]\\$ but can never be exactly 0. The minimum\nresult magnitude is \\$frac{1}{2\\^{17}}\\$ (and therefore results can lie\nwithin the denormalised number range for *half-precision*).\n\nNote that this instruction can be combined with `urand32`/`urand64` to\nproduce random, uniformly distributed floating-point values.\n"),
        ("lds8step", "* `lds8step $mDst0, $mBase0, $mDelta0+=, simm8`\n* `lds8step $mDst0, $mBase0, $mDelta0+=, $mStride0`\n\nSign-extending 8-bit load with post-incrementing address.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is a 32-bit value formed by sign-extending the 8-bit data\n        value.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register.\n"),
        ("f16tof32", "* `f16tof32 $aDst0, $aSrc0`\n\nConvert a *f16* value to *single-precision*.\n"),
        ("bri", "* `bri zimm19`\n\nUnconditional branch to absolute address. Immediate provides\nword-addressed absolute destination address.\n"),
        ("f32absadd", "* `f32absadd $aDst0, $aSrc0, $aSrc1`\n\nScalar *single-precision* addition of two absolute register source\nvalues.\n"),
        ("$azeros", "Alias for `$a14:15`. This register is read-only and always returns 0.\n"),
        ("f16v4hihoslic", "* `f16v4hihoslic $aDst0, $aSrc0:Src0+1, $aSrc1, enumFlags`\n\n*Half-precision* floating-point vector slim convolution.\n\nInput partial-sums are *half-precision*. Results are *half-precision*\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1    \\$AACC\\[14\\]   \\$AACC\\[10\\]           \\$AACC\\[6\\]         \\$AACC\\[2\\]        \\$AACC\\[12\\]   \\$AACC\\[8\\]            \\$AACC\\[4\\]         \\$AACC\\[0\\]        \\$aDst0\n  ------------- -------------- ---------------------- ------------------- ------------------ -------------- ---------------------- ------------------- ------------------ ---------\n  x0\\|P0,P1     **-**          R1=x0.**CW**5,0+P1     **-**               **-**              **-**          R0=x0.**CW**4,0+P0     **-**               **-**              **-**\n\n  x1\\|P2,P3     **-**          R3=x1.**CW**5,0+P3     R1+=x1.**CW**3,0    **-**              **-**          R2=x1.**CW**4,0+P2     R0+=x1.**CW**2,0    **-**              **-**\n\n  x2\\|P4,P5     **-**          R5=x2.**CW**5,0+P5     R3+=x2.**CW**3,0    R1+=x2.**CW**1,0   **-**          R4=x2.**CW**4,0+P4     R2+=x2.**CW**2,0    R0+=x2.**CW**0,0   **-**\n\n  x3\\|P6,P7     **-**          R7=x3.**CW**5,0+P7     R5+=x3.**CW**3,0    R3+=x3.**CW**1,0   **-**          R6=x3.**CW**4,0+P6     R4+=x3.**CW**2,0    R2+=x3.**CW**0,0   R0,R1\n\n  x4\\|P8,P9     **-**          R9=x4.**CW**5,0+P9     R7+=x4.**CW**3,0    R5+=x4.**CW**1,0   **-**          R8=x4.**CW**4,0+P8     R6+=x4.**CW**2,0    R4+=x4.**CW**0,0   R2,R3\n\n  x5\\|P10,P11   **-**          R11=x5.**CW**5,0+P11   R9+=x5.**CW**3,0    R7+=x5.**CW**1,0   **-**          R10=x5.**CW**4,0+P10   R8+=x5.**CW**2,0    R6+=x5.**CW**0,0   R4,R5\n\n  x6\\|P12,P13   **-**          R13=x6.**CW**5,0+P13   R11+=x6.**CW**3,0   R9+=x6.**CW**1,0   **-**          R12=x6.**CW**4,0+P12   R10+=x6.**CW**2,0   R8+=x6.**CW**0,0   R6,R7\n  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f16v4hihoslic, 2x1x3x4 example sequence\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1    \\$AACC\\[14\\]           \\$AACC\\[10\\]        \\$AACC\\[6\\]        \\$AACC\\[2\\]        \\$AACC\\[12\\]           \\$AACC\\[8\\]         \\$AACC\\[4\\]        \\$AACC\\[0\\]        \\$aDst0\n  ------------- ---------------------- ------------------- ------------------ ------------------ ---------------------- ------------------- ------------------ ------------------ ---------\n  x0\\|P0,P1     R1=x0.**CW**7,0+P1     **-**               **-**              **-**              R0=x0.**CW**6,0+P0     **-**               **-**              **-**              **-**\n\n  x1\\|P2,P3     R3=x1.**CW**7,0+P3     R1+=x1.**CW**5,0    **-**              **-**              R2=x1.**CW**6,0+P2     R0+=x1.**CW**4,0    **-**              **-**              **-**\n\n  x2\\|P4,P5     R5=x2.**CW**7,0+P5     R3+=x2.**CW**5,0    R1+=x2.**CW**3,0   **-**              R4=x2.**CW**6,0+P4     R2+=x2.**CW**4,0    R0+=x2.**CW**2,0   **-**              **-**\n\n  x3\\|P6,P7     R7=x3.**CW**7,0+P7     R5+=x3.**CW**5,0    R3+=x3.**CW**3,0   R1+=x3.**CW**1,0   R6=x3.**CW**6,0+P6     R4+=x3.**CW**4,0    R2+=x3.**CW**2,0   R0+=x3.**CW**0,0   **-**\n\n  x4\\|P8,P9     R9=x4.**CW**7,0+P9     R7+=x4.**CW**5,0    R5+=x4.**CW**3,0   R3+=x4.**CW**1,0   R8=x4.**CW**6,0+P8     R6+=x4.**CW**4,0    R4+=x4.**CW**2,0   R2+=x4.**CW**0,0   R0,R1\n\n  x5\\|P10,P11   R11=x5.**CW**7,0+P11   R9+=x5.**CW**5,0    R7+=x5.**CW**3,0   R5+=x5.**CW**1,0   R10=x5.**CW**6,0+P10   R8+=x5.**CW**4,0    R6+=x5.**CW**2,0   R4+=x5.**CW**0,0   R2,R3\n\n  x6\\|P12,P13   R13=x6.**CW**7,0+P13   R11+=x6.**CW**5,0   R9+=x6.**CW**3,0   R7+=x6.**CW**1,0   R12=x6.**CW**6,0+P12   R10+=x6.**CW**4,0   R8+=x6.**CW**2,0   R6+=x6.**CW**0,0   R4,R5\n  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f16v4hihoslic, 1x4 example sequence\n\nPn is *half-precision* input partial-sum *n* xn is an *f16v4* input\nvector **CW**m,n is the common weight state **\\$CWEI**\\_*m*\\_*n* Rn is\nthe final *half-precision* result of successive dot-product\naccumulations that began with Pn\n"),
        ("f32toui32", "* `f32toui32 $aDst0, $aSrc0`\n\nConvert a *single-precision* floating-point value to a unsigned integer,\nrounding as per `$FP_CTL.RND`.\n"),
        ("atom", "* `atom $mDst0, $aSrc0`\n\nCopy an ARF register value to MRF. No format conversion is performed.\n"),
        ("$a15", "`$a15` register. Always reads 0. You probably meant to use `$azero` or `$azeros`.\n"),
        ("f16v4sufromui", "* `f16v4sufromui $aDst0:Dst0+1, $aSrc0:Src0+1`\n\nSymmetric, unbiased conversion from 4-element vector of unsigned 16-bit\nintegers to 4-element *half-precision* vector.\n\nEach of the *half-precision* results lies within the range\n\\$\\[-frac{1}{2}, frac{1}{2}\\]\\$ but can never be exactly 0. The minimum\nresult magnitude is \\$frac{1}{2\\^{17}}\\$ (and therefore results can lie\nwithin the denormalised number range for *half-precision*).\n\nNote that this instruction can be combined with `urand32`/`urand64` to\nproduce random, uniformly distributed floating-point values.\n"),
        ("and64", "* `and64 $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n64-bit bitwise logical AND of two ARF source register-pairs.\n"),
        ("f32v2absmax", "* `f32v2absmax $aDst0:Dst0+1, $aSrc1:Src1+1, $aSrc0:Src0+1`\n\n*Single-precision* 2-element vector element-wise max of absolute values.\n"),
        ("brnz", "* `brnz $mSrc0, zimm19`\n\nConditional branch to absolute address. Branch taken if and only if\nregister value **is not 0**. Immediate provides word-addressed absolute\ndestination address.\n\n## Note\n\nThis instruction considers the floating-point *single-precision* value\n-0.0 to not be zero (+0.0)\n"),
        ("$FP_ICTL", "Floating point control register initial value. The *worker*\nfloating-point control register `$FP_CTL` is initialised with the\ncontents of this register prior to worker activation.\n\nSee `run` and `runall`\n"),
        ("f32tanh", "* `f32tanh $aDst0, $aSrc0`\n\n*Single-precision* floating-point hyperbolic tangent.\n"),
        ("f32add", "* `f32add $aDst0, $aSrc0, $aSrc1`\n\n*Single-precision* addition of two register source values.\n"),
        ("stm32step", "* `stm32step $mSrc0, $mBase0+=, $mStride0`\n\nNaturally aligned 32-bit store from MRF with scaled post-incrementing\naddress.\n\nSource register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n\nAddress auto-increment:\n\n:   -   The base address register operand is post-incremented by the\n        signed stride register value (after the value has been scaled to\n        atom size).\n"),
        ("$CTXT_STS", "See `$CTXT_STS`\n"),
        ("f32tof16", "* `f32tof16 $aDst0, $aSrc0`\n\nConvert a *single-precision* value to *f16*, using the rounding mode as\nspecified by `$FP_CTL.RND`/`$FP_CTL.ESR`. Supports stochastic rounding.\nSee fp_format_conversions.\n\nThe 16-bit result of the conversion is broadcast to (duplicated into) a\nsingle ARF register, producing a 2-element vector of identical *f16*\nvalues.\n"),
        ("bitrev8", "* `bitrev8 $mDst0, $mSrc0`\n\nReverse the bit order of each bit inside each byte of a register.\n"),
        ("$mzero", "Alias for `$m15`. This register is read-only and always returns 0.\n"),
        ("f16v2max", "* `f16v2max $aDst0, $aSrc0, $aSrc1`\n\n*Half-precision* floating-point vector max\n"),
        ("br", "* `br $mSrc0`\n\nUnconditional absolute branch to register target address.\n"),
        ("f32v2axpy", "* `f32v2axpy $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Single-precision* 2-element vector **z** = *a***x** + **y** The scalar\nmultiplicand *a* is provided by the internal state element `$TAS`.\n\nResults are stored within the accumulator state. Destination registers\nare written with the previous accumulator state.\n"),
        ("f16v4maxc", "* `f16v4maxc $aDst0, $aSrc0:Src0+1`\n\n*Half-precision* 4-element vector 2x2 lateral maximum.\n"),
        ("$a3", "`$a3` general purpose arithmetic register.\n"),
        ("$m9", "`$m9` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("ldconst", "Load a constant into a register. This can be used to load 32-bit constants which takes two actual instructions. This compiles to `setzi` instructions.\n"),
        ("f32v2mul", "* `f32v2mul $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2mul $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point 2 element vector, Hadamard product\n"),
        ("f16v4class", "* `f16v4class $aDst0, $aSrc0:Src0+1`\n\n*Half-precision* floating-point vector classifier. IEEE 754-2008: 5.7.2\n"),
        ("st64step", "* `st64step $aSrc0:Src0+1, $mBase0, $mDelta0+=, simm8`\n* `st64step $aSrc0:Src0+1, $mBase0, $mDelta0+=, $mStride0`\n\nNaturally aligned 64-bit store with scaled post-incrementing address.\n\nSource register-file: ARF only (a naturally aligned register-pair)\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
    ],
};

pub struct CompletionDef<'a> {
    pub label: &'a str,
    pub detail: &'a str,
    pub documentation: &'a str,
}

pub const COMPLETIONS: &[CompletionDef] = &[
  CompletionDef { label: "$ANS_DCOUNT", detail: "$ANS_DCOUNT", documentation: "Automatic non-participatory sync down-counter. VALUE is decremented for\neach sync-acknowledge received in response to the automatic assertion of\nthe sync request signal.\n" },
  CompletionDef { label: "$CCCSLOAD", detail: "$CCCSLOAD", documentation: "Post-incrementing load address for `ld64putcs` and `ld128putcs`.\n" },
  CompletionDef { label: "$COUNT_L", detail: "$COUNT_L", documentation: "[Tile]{.title-ref} cycle counter value. Lower 32-bits\n" },
  CompletionDef { label: "$COUNT_U", detail: "$COUNT_U", documentation: "[Tile]{.title-ref} cycle counter value. Upper 32-bits\n" },
  CompletionDef { label: "$CR", detail: "$CR", documentation: "Supervisor Control Register.\n" },
  CompletionDef { label: "$CTXT_STS", detail: "$CTXT_STS", documentation: "CSR alias. This register can be read to ascertain the execution status\nof all Tile contexts.\n" },
  CompletionDef { label: "$DBG_BRK_ID", detail: "$DBG_BRK_ID", documentation: "Id of BRK channel which caused the last BREAK *exception event*. See\ndebug_model.\n" },
  CompletionDef { label: "$DBG_CTL", detail: "$DBG_CTL", documentation: "Debug control register. See debug_model.\n" },
  CompletionDef { label: "$DBG_DATA", detail: "$DBG_DATA", documentation: "CSR alias. This register can be configured (via `$DBG_ECSR`) to behave\nin two different ways:\n\n1.  A general purpose 32-bit data register for passing data into and\n    out ofTile via the debug bus.\n2.  To present the current value of `$PC` for any context.\n" },
  CompletionDef { label: "$DBG_ECLR", detail: "$DBG_ECLR", documentation: "Debug exception clear register alias.\n" },
  CompletionDef { label: "$DBG_ECSR", detail: "$DBG_ECSR", documentation: "Debug external control and status register alias.\n" },
  CompletionDef { label: "$DBG_IEXEC", detail: "$DBG_IEXEC", documentation: "Writes to this register must be correctly formed, complete instruction\nopcode values, including all field information. Writes to this register\nwill cause the value written to be injected as an instruction into the\ninstruction stream of the context indicated by `$DBG_IOWNER`, assuming\nthat context is in a suitable state.\n" },
  CompletionDef { label: "$DBG_IOWNER", detail: "$DBG_IOWNER", documentation: "Indicates which context will be issued instructions written to\n`$DBG_IEXEC`.\n" },
  CompletionDef { label: "$DBG_RBRK", detail: "$DBG_RBRK", documentation: "retirement_brk control.\n" },
  CompletionDef { label: "$DBG_RBRK_VERT", detail: "$DBG_RBRK_VERT", documentation: "Address for comparison against `$VERTEX_BASE`\n" },
  CompletionDef { label: "$EXCHANGE_ADJ", detail: "$EXCHANGE_ADJ", documentation: "Exchange configuration adjustment register.\n" },
  CompletionDef { label: "$EXCHANGE_CTL", detail: "$EXCHANGE_CTL", documentation: "Read only CSR alias. Exchange control register.\n" },
  CompletionDef { label: "$FP_CLR", detail: "$FP_CLR", documentation: "Floating-point exception/state clear.\n" },
  CompletionDef { label: "$FP_CTL", detail: "$FP_CTL", documentation: "Floating-point control register.\n" },
  CompletionDef { label: "$FP_ICTL", detail: "$FP_ICTL", documentation: "Floating-point control register initial value.\n" },
  CompletionDef { label: "$FP_STS", detail: "$FP_STS", documentation: "Floating-point status register.\n" },
  CompletionDef { label: "$INCOMING_BASE", detail: "$INCOMING_BASE", documentation: "*Tile Memory* base address for internal exchange incoming messages.\n" },
  CompletionDef { label: "$INCOMING_DCOUNT", detail: "$INCOMING_DCOUNT", documentation: "Read-only CSR alias. Incoming message down counter\n" },
  CompletionDef { label: "$INCOMING_DELTA", detail: "$INCOMING_DELTA", documentation: "Auto-incrementingTile Memory delta offset for internal exchange incoming\nmessages.\n" },
  CompletionDef { label: "$INCOMING_FORMAT", detail: "$INCOMING_FORMAT", documentation: "See exchange_internal_receive and timpl_tileincomingformat\n" },
  CompletionDef { label: "$INCOMING_MUX", detail: "$INCOMING_MUX", documentation: "Source identifier for incoming messages (see\ntimpl_incoming_mux_address_map).\n" },
  CompletionDef { label: "$INCOMING_MUXPAIR", detail: "$INCOMING_MUXPAIR", documentation: "Tile pair alias for `$INCOMING_MUX`.\n" },
  CompletionDef { label: "$INCOMING_SINIT", detail: "$INCOMING_SINIT", documentation: "Sync initialisation value for `$INCOMING_DELTA`.\n" },
  CompletionDef { label: "$OUTGOING_BASE", detail: "$OUTGOING_BASE", documentation: "Common base address for send instructions. Used by all send\ninstructions.\n" },
  CompletionDef { label: "$OUTGOING_DELTA", detail: "$OUTGOING_DELTA", documentation: "Outgoing message address delta for send instructions. Used and modified\nby a subset of send instructions.\n" },
  CompletionDef { label: "$PC", detail: "$PC", documentation: "Context Program Counter.\n" },
  CompletionDef { label: "$PRNG_0_0", detail: "$PRNG_0_0", documentation: "The least significant 32-bits of \\$PRNG_0.\n" },
  CompletionDef { label: "$PRNG_0_1", detail: "$PRNG_0_1", documentation: "The most significant 32-bits of \\$PRNG_0.\n" },
  CompletionDef { label: "$PRNG_1_0", detail: "$PRNG_1_0", documentation: "The least significant 32-bits of \\$PRNG_1.\n" },
  CompletionDef { label: "$PRNG_1_1", detail: "$PRNG_1_1", documentation: "The most significant 32-bits of \\$PRNG_1.\n" },
  CompletionDef { label: "$PRNG_SEED", detail: "$PRNG_SEED", documentation: "32-bit Pseudo-random-number-generator initialisation.\n" },
  CompletionDef { label: "$REPEAT_COUNT", detail: "$REPEAT_COUNT", documentation: "`rpt` loop down-counter.\n" },
  CompletionDef { label: "$REPEAT_END", detail: "$REPEAT_END", documentation: "`rpt` loop end address.\n" },
  CompletionDef { label: "$REPEAT_FIRST", detail: "$REPEAT_FIRST", documentation: "`rpt` loop start address.\n" },
  CompletionDef { label: "$SCOUNT_L", detail: "$SCOUNT_L", documentation: "[Tile]{.title-ref} cycle counter value. Lower 32-bits. An explicit write\nvia `put` always wins over hardware clock tick.\n" },
  CompletionDef { label: "$SCOUNT_U", detail: "$SCOUNT_U", documentation: "[Tile]{.title-ref} cycle counter value. Upper 32-bits. An explicit write\nvia `put` always wins over hardware clock tick.\n" },
  CompletionDef { label: "$SNOTIFY", detail: "$SNOTIFY", documentation: "Software notification register. Each implemented field controls an\nexternal implementation specific hardware feature.\n" },
  CompletionDef { label: "$SSR", detail: "$SSR", documentation: "Supervisor Status Register.\n" },
  CompletionDef { label: "$TAS", detail: "$TAS", documentation: "**T**he **a**xpy **s**cale (or **T**emporary **a**mp **s**torage).\n" },
  CompletionDef { label: "$TDI_CLR", detail: "$TDI_CLR", documentation: "TDI error clear.\n" },
  CompletionDef { label: "$TDI_CTL", detail: "$TDI_CTL", documentation: "Target Debug Interface control register.\n" },
  CompletionDef { label: "$TDI_STS", detail: "$TDI_STS", documentation: "TDI status register\n" },
  CompletionDef { label: "$TILE_ID", detail: "$TILE_ID", documentation: "Unique identifier for thisTile instance (logicalTile ID).\n" },
  CompletionDef { label: "$VERTEX_BASE", detail: "$VERTEX_BASE", documentation: "Vertex data structure pointer.\n" },
  CompletionDef { label: "$WORKER_BASE", detail: "$WORKER_BASE", documentation: "Worker context scratch space base address.\n" },
  CompletionDef { label: "$WORKER{0}_BASE", detail: "$WORKER{0}_BASE", documentation: "Worker thread {} scratch space base address. Read/write alias of\n`$WORKER_BASE`.\n" },
  CompletionDef { label: "$WSR", detail: "$WSR", documentation: "Worker context status register.\n" },
  CompletionDef { label: "$a0", detail: "$a0", documentation: "`$a0` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a0:1", detail: "$a0:1", documentation: "`$a0` and `$a1` together as a 64-bit general purpose arithmetic register.\n" },
  CompletionDef { label: "$a1", detail: "$a1", documentation: "`$a1` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a14", detail: "$a14", documentation: "`$a14` register. Always reads 0. Also available through the `$azero` or `$azeros` (64-bit) alias.\n" },
  CompletionDef { label: "$a15", detail: "$a15", documentation: "`$a15` register. Always reads 0. You probably meant to use `$azero` or `$azeros`.\n" },
  CompletionDef { label: "$a2", detail: "$a2", documentation: "`$a2` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a2:3", detail: "$a2:3", documentation: "`$a2` and `$a3` together as a 64-bit general purpose arithmetic register.\n" },
  CompletionDef { label: "$a3", detail: "$a3", documentation: "`$a3` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a4", detail: "$a4", documentation: "`$a4` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a4:5", detail: "$a4:5", documentation: "`$a4` and `$a5` together as a 64-bit general purpose arithmetic register.\n" },
  CompletionDef { label: "$a5", detail: "$a5", documentation: "`$a5` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a6", detail: "$a6", documentation: "`$a6` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a6:7", detail: "$a6:7", documentation: "`$a6` and `$a7` together as a 64-bit general purpose arithmetic register.\n" },
  CompletionDef { label: "$a7", detail: "$a7", documentation: "`$a7` general purpose arithmetic register.\n" },
  CompletionDef { label: "$azero", detail: "$azero", documentation: "Alias for `$a15`. This register is read-only and always returns 0.\n" },
  CompletionDef { label: "$azeros", detail: "$azeros", documentation: "Alias for `$a14:15`. This register is read-only and always returns 0.\n" },
  CompletionDef { label: "$fp", detail: "$fp", documentation: "Alias for `$m5`. Frame Pointer. Points to the part of the stack used by the current function.\n" },
  CompletionDef { label: "$lr", detail: "$lr", documentation: "Alias for `$m6`. Link Register. This register is commonly used to hold the return address of a function.\n" },
  CompletionDef { label: "$m0", detail: "$m0", documentation: "`$m0` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m1", detail: "$m1", documentation: "`$m1` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m10", detail: "$m10", documentation: "`$m10` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m11", detail: "$m11", documentation: "`$m11` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m12", detail: "$m12", documentation: "`$m12` Worker Base Register. Returns the worker context scratch space base address. Also available through the alias `$worker_base`.\n" },
  CompletionDef { label: "$m13", detail: "$m13", documentation: "`$m13` Vertex Base Register. Vertex data structure pointer. Initialised on behalf of a Worker context by the Supervisor via `run` or `runall`. This register can also be read through the `$vertex_base` alias.\n" },
  CompletionDef { label: "$m14", detail: "$m14", documentation: "`$m14` register. Read only. Returns an implementation-specific value.\n" },
  CompletionDef { label: "$m15", detail: "$m15", documentation: "`$m15` register. Read only. Always reads 0. Also available through the `$mzero` alias.\n" },
  CompletionDef { label: "$m2", detail: "$m2", documentation: "`$m2` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m3", detail: "$m3", documentation: "`$m3` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m4", detail: "$m4", documentation: "`$m4` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m5", detail: "$m5", documentation: "`$m5` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m6", detail: "$m6", documentation: "`$m6` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m7", detail: "$m7", documentation: "`$m7` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m8", detail: "$m8", documentation: "`$m8` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m9", detail: "$m9", documentation: "`$m9` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$mvertex_base", detail: "$mvertex_base", documentation: "The Vertex Base Register (an alias for `$m13`). Initialised on behalf of a Worker context by the Supervisor via `run` or `runall`.\n" },
  CompletionDef { label: "$mworker_base", detail: "$mworker_base", documentation: "The Worker Base Register (an alias for `$m12`). Returns the worker context scratch space base address.\n" },
  CompletionDef { label: "$mzero", detail: "$mzero", documentation: "Alias for `$m15`. This register is read-only and always returns 0.\n" },
  CompletionDef { label: "$sp", detail: "$sp", documentation: "The stack pointer (an alias for `$m7`). This register is commonly used to hold the address of the bottom of the stack.\n" },
  CompletionDef { label: "abs", detail: "abs $mDst0 $mSrc0", documentation: "Absolute value of signed 32-bit integer\n" },
  CompletionDef { label: "add", detail: "add $mDst0 $mSrc0 $mSrc1 (and 2 more)", documentation: "Integer addition\n" },
  CompletionDef { label: "and", detail: "and $mDst0 $mSrc0 $mSrc1 (and 4 more)", documentation: "32-bit bitwise logical AND\n" },
  CompletionDef { label: "and64", detail: "and64 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "64-bit bitwise logical AND\n" },
  CompletionDef { label: "andc", detail: "andc $mDst0 $mSrc0 $mSrc1 (and 4 more)", documentation: "32-bit bitwise logical AND Complement\n" },
  CompletionDef { label: "andc64", detail: "andc64 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "64-bit bitwise logical AND Complement\n" },
  CompletionDef { label: "atom", detail: "atom $mDst0 $aSrc0", documentation: "Copy an *arf* register value to *mrf*\n" },
  CompletionDef { label: "bitrev8", detail: "bitrev8 $mDst0 $mSrc0", documentation: "Byte-wise bit order reversal\n" },
  CompletionDef { label: "br", detail: "br $mSrc0", documentation: "Unconditional absolute branch to register target\n" },
  CompletionDef { label: "bri", detail: "bri zimm19", documentation: "Unconditional absolute branch to immediate target\n" },
  CompletionDef { label: "brneg", detail: "brneg $mSrc0 zimm19", documentation: "Branch if negative\n" },
  CompletionDef { label: "brnz", detail: "brnz $mSrc0 zimm19", documentation: "Branch if not zero\n" },
  CompletionDef { label: "brnzdec", detail: "brnzdec $mSrcDst0 zimm19", documentation: "Branch if not zero, with counter decrement\n" },
  CompletionDef { label: "brpos", detail: "brpos $mSrc0 zimm19", documentation: "Branch if positive\n" },
  CompletionDef { label: "brz", detail: "brz $mSrc0 zimm19", documentation: "Branch if zero\n" },
  CompletionDef { label: "brzdec", detail: "brzdec $mSrcDst0 zimm19", documentation: "Branch if zero, with counter decrement\n" },
  CompletionDef { label: "call", detail: "call $mDst0 zimm20", documentation: "Function call\n" },
  CompletionDef { label: "clz", detail: "clz $mDst0 $mSrc0", documentation: "Count leading zero bits\n" },
  CompletionDef { label: "cmpeq", detail: "cmpeq $mDst0 $mSrc0 $mSrc1 (and 2 more)", documentation: "Equality test\n" },
  CompletionDef { label: "cmpne", detail: "cmpne $mDst0 $mSrc0 $mSrc1", documentation: "Inequality test\n" },
  CompletionDef { label: "cmpslt", detail: "cmpslt $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "Signed less-than test\n" },
  CompletionDef { label: "cmpult", detail: "cmpult $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "Unsigned less-than test\n" },
  CompletionDef { label: "cms", detail: "cms $mDst0 $mSrc0", documentation: "Count matching sign bits\n" },
  CompletionDef { label: "exitneg", detail: "exitneg $mSrc0", documentation: "Worker thread termination\n" },
  CompletionDef { label: "exitnz", detail: "exitnz $mSrc0", documentation: "Worker thread termination\n" },
  CompletionDef { label: "exitpos", detail: "exitpos $mSrc0", documentation: "Worker thread termination\n" },
  CompletionDef { label: "exitz", detail: "exitz $mSrc0", documentation: "Worker thread termination\n" },
  CompletionDef { label: "f16tof32", detail: "f16tof32 $aDst0 $aSrc0", documentation: "*f16* to *single-precision*\n" },
  CompletionDef { label: "f16v2absadd", detail: "f16v2absadd $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector add of absolutes\n" },
  CompletionDef { label: "f16v2absmax", detail: "f16v2absmax $aDst0 $aSrc1 $aSrc0", documentation: "*Half-precision* floating-point vector max of absolutes\n" },
  CompletionDef { label: "f16v2add", detail: "f16v2add $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector add\n" },
  CompletionDef { label: "f16v2clamp", detail: "f16v2clamp $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector min-of-maximum\n" },
  CompletionDef { label: "f16v2class", detail: "f16v2class $aDst0 $aSrc0", documentation: "*Half-precision* floating-point vector classifier\n" },
  CompletionDef { label: "f16v2cmac", detail: "f16v2cmac $aSrc0 $aSrc1", documentation: "*Half-precision* vector multiply with lateral sum and accumulate\n" },
  CompletionDef { label: "f16v2cmpeq", detail: "f16v2cmpeq $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* vector equality test\n" },
  CompletionDef { label: "f16v2cmpge", detail: "f16v2cmpge $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector greater-than-or-equal-to test\n" },
  CompletionDef { label: "f16v2cmpgt", detail: "f16v2cmpgt $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector greater-than test\n" },
  CompletionDef { label: "f16v2cmple", detail: "f16v2cmple $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector less-than-or-equal-to test\n" },
  CompletionDef { label: "f16v2cmplt", detail: "f16v2cmplt $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector less-than test\n" },
  CompletionDef { label: "f16v2cmpne", detail: "f16v2cmpne $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector inequality test\n" },
  CompletionDef { label: "f16v2exp", detail: "f16v2exp $aDst0 $aSrc0", documentation: "Natural exponential\n" },
  CompletionDef { label: "f16v2exp2", detail: "f16v2exp2 $aDst0 $aSrc0", documentation: "Base 2 exponential\n" },
  CompletionDef { label: "f16v2gina", detail: "f16v2gina $aDst0 $aSrc0 zimm12", documentation: "Get and initialise accumulators\n" },
  CompletionDef { label: "f16v2grand", detail: "f16v2grand $aDst0", documentation: "Gaussian distribution, 2-element *half-precision* random vector\n" },
  CompletionDef { label: "f16v2ln", detail: "f16v2ln $aDst0 $aSrc0", documentation: "*Half-precision* floating-point vector natural logarithm\n" },
  CompletionDef { label: "f16v2log2", detail: "f16v2log2 $aDst0 $aSrc0", documentation: "*Half-precision* floating-point vector base 2 logarithm\n" },
  CompletionDef { label: "f16v2max", detail: "f16v2max $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector max\n" },
  CompletionDef { label: "f16v2maxc", detail: "f16v2maxc $aDst0 $aSrc0", documentation: "*Half-precision* vector lateral max\n" },
  CompletionDef { label: "f16v2min", detail: "f16v2min $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector element-wise minimum\n" },
  CompletionDef { label: "f16v2mul", detail: "f16v2mul $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* 2-element vector Hadamard product\n" },
  CompletionDef { label: "f16v2sigm", detail: "f16v2sigm $aDst0 $aSrc0", documentation: "*Half-precision* 2-element vector logistic\n" },
  CompletionDef { label: "f16v2sub", detail: "f16v2sub $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector subtract\n" },
  CompletionDef { label: "f16v2sufromui", detail: "f16v2sufromui $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f16v2sum", detail: "f16v2sum $aDst0 $aSrc0", documentation: "*Half-precision* vector lateral summation\n" },
  CompletionDef { label: "f16v2tanh", detail: "f16v2tanh $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f16v2tof32", detail: "f16v2tof32 $aDst0:Dst0+1 $aSrc0", documentation: "*f16* pair to *single-precision* pair\n" },
  CompletionDef { label: "f16v4absacc", detail: "f16v4absacc $aSrc0:Src0+1", documentation: "*Half-precision* vector accumulation of absolutes\n" },
  CompletionDef { label: "f16v4absadd", detail: "f16v4absadd $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector addition of absolutes\n" },
  CompletionDef { label: "f16v4absmax", detail: "f16v4absmax $aDst0:Dst0+1 $aSrc1:Src1+1 $aSrc0:Src0+1", documentation: "*Half-precision* 4-element vector max of absolutes\n" },
  CompletionDef { label: "f16v4acc", detail: "f16v4acc $aSrc0:Src0+1", documentation: "*Half-precision* vector accumulate\n" },
  CompletionDef { label: "f16v4add", detail: "f16v4add $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector addition\n" },
  CompletionDef { label: "f16v4clamp", detail: "f16v4clamp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1", documentation: "*Half-precision* floating-point vector min-of-maximum\n" },
  CompletionDef { label: "f16v4class", detail: "f16v4class $aDst0 $aSrc0:Src0+1", documentation: "*Half-precision* floating-point vector classifier\n" },
  CompletionDef { label: "f16v4cmac", detail: "f16v4cmac $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector multiply with 2x2 lateral sum and accumulate\n" },
  CompletionDef { label: "f16v4cmpeq", detail: "f16v4cmpeq $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector equality test\n" },
  CompletionDef { label: "f16v4cmpge", detail: "f16v4cmpge $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector greater-than or equal-to test\n" },
  CompletionDef { label: "f16v4cmpgt", detail: "f16v4cmpgt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector greater-than test\n" },
  CompletionDef { label: "f16v4cmple", detail: "f16v4cmple $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector less-than or equal-to test\n" },
  CompletionDef { label: "f16v4cmplt", detail: "f16v4cmplt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector less-than test\n" },
  CompletionDef { label: "f16v4cmpne", detail: "f16v4cmpne $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector inequality test\n" },
  CompletionDef { label: "f16v4gacc", detail: "f16v4gacc $aDst0:Dst0+1", documentation: "Get accumulators\n" },
  CompletionDef { label: "f16v4hihoamp", detail: "f16v4hihoamp $aDst0 $aSrc0:Src0+1 $aSrc1 enumFlags", documentation: "*Half-precision* vector accumulating matrix-vector product\n" },
  CompletionDef { label: "f16v4hihoslic", detail: "f16v4hihoslic $aDst0 $aSrc0:Src0+1 $aSrc1 enumFlags", documentation: "*Half-precision* slim convolution\n" },
  CompletionDef { label: "f16v4hihov4amp", detail: "f16v4hihov4amp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Half-precision* vector accumulating matrix-vector product\n" },
  CompletionDef { label: "f16v4hihov4slic", detail: "f16v4hihov4slic $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Half-precision* slim convolution\n" },
  CompletionDef { label: "f16v4istacc", detail: "f16v4istacc $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "Sort/shuffle (permute) through accumulators, with new input\n" },
  CompletionDef { label: "f16v4max", detail: "f16v4max $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector max\n" },
  CompletionDef { label: "f16v4maxc", detail: "f16v4maxc $aDst0 $aSrc0:Src0+1", documentation: "*Half-precision* vector 2x2 lateral max\n" },
  CompletionDef { label: "f16v4min", detail: "f16v4min $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector minimum\n" },
  CompletionDef { label: "f16v4mix", detail: "f16v4mix $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector z = ax + y\n" },
  CompletionDef { label: "f16v4mul", detail: "f16v4mul $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* 4-element vector Hadamard product\n" },
  CompletionDef { label: "f16v4rmask", detail: "f16v4rmask $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1", documentation: "*Half-precision* vector random mask\n" },
  CompletionDef { label: "f16v4sihoamp", detail: "f16v4sihoamp $aDst0 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Half-precision* floating-point vector accumulating matrix-vector\nproduct\n" },
  CompletionDef { label: "f16v4sihoslic", detail: "f16v4sihoslic $aDst0 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Half-precision* floating-point vector slim convolution\n" },
  CompletionDef { label: "f16v4sisoamp", detail: "f16v4sisoamp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*f16* accumulating matrix-vector product\n" },
  CompletionDef { label: "f16v4sisoslic", detail: "f16v4sisoslic $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*f16* slim convolution\n" },
  CompletionDef { label: "f16v4stacc", detail: "f16v4stacc $aDst0:Dst0+1 enumFlags", documentation: "Sort/shuffle (permute) through accumulators (no new input)\n" },
  CompletionDef { label: "f16v4sub", detail: "f16v4sub $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector subtraction\n" },
  CompletionDef { label: "f16v4sufromui", detail: "f16v4sufromui $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "\n" },
  CompletionDef { label: "f16v4sum", detail: "f16v4sum $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "*Half-precision* vector 2x2 lateral summation\n" },
  CompletionDef { label: "f16v8absacc", detail: "f16v8absacc $aSrc0:Src0+3", documentation: "*Half-precision* 8-element vector accumulation of absolutes\n" },
  CompletionDef { label: "f16v8acc", detail: "f16v8acc $aSrc0:Src0+3", documentation: "*Half-precision* 8-element vector accumulate\n" },
  CompletionDef { label: "f16v8sqacc", detail: "f16v8sqacc $aSrc0:Src0+3", documentation: "*Half-precision* vector accumulate squares\n" },
  CompletionDef { label: "f32absadd", detail: "f32absadd $aDst0 $aSrc0 $aSrc1", documentation: "Scalar floating-point addition of absolutes\n" },
  CompletionDef { label: "f32absmax", detail: "f32absmax $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point max of absolute values\n" },
  CompletionDef { label: "f32add", detail: "f32add $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point addition\n" },
  CompletionDef { label: "f32clamp", detail: "f32clamp $aDst0 $aSrc0 $aSrc1:Src1+1", documentation: "*Single-precision* floating-point vector min-of-maximum\n" },
  CompletionDef { label: "f32class", detail: "f32class $aDst0 $aSrc0", documentation: "*Single-precision* floating-point number classifier\n" },
  CompletionDef { label: "f32cmpeq", detail: "f32cmpeq $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point equality test\n" },
  CompletionDef { label: "f32cmpge", detail: "f32cmpge $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point greater than or equal test\n" },
  CompletionDef { label: "f32cmpgt", detail: "f32cmpgt $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point greater than\n" },
  CompletionDef { label: "f32cmple", detail: "f32cmple $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point less or equal\n" },
  CompletionDef { label: "f32cmplt", detail: "f32cmplt $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point less than\n" },
  CompletionDef { label: "f32cmpne", detail: "f32cmpne $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point not equal\n" },
  CompletionDef { label: "f32div", detail: "f32div $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point division\n" },
  CompletionDef { label: "f32exp", detail: "f32exp $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f32exp2", detail: "f32exp2 $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f32fromi32", detail: "f32fromi32 $aDst0 $aSrc0", documentation: "Signed integer to :term:\\'single-precision\\` floating-point conversion\n" },
  CompletionDef { label: "f32fromui32", detail: "f32fromui32 $aDst0 $aSrc0", documentation: "Unsigned integer to :term:\\'single-precision\\` floating-point conversion\n" },
  CompletionDef { label: "f32int", detail: "f32int $aDst0 $aSrc1 enumRnd", documentation: "round to integral\n" },
  CompletionDef { label: "f32ln", detail: "f32ln $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f32log2", detail: "f32log2 $aDst0 $aSrc0", documentation: "Base 2 logarithm\n" },
  CompletionDef { label: "f32mac", detail: "f32mac $aSrc0 $aSrc1", documentation: "Single precision floating-point multiply and accumulate\n" },
  CompletionDef { label: "f32max", detail: "f32max $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point max\n" },
  CompletionDef { label: "f32min", detail: "f32min $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point min\n" },
  CompletionDef { label: "f32mul", detail: "f32mul $aDst0 $aSrc0 $aSrc1", documentation: "Single precision floating-point multiply\n" },
  CompletionDef { label: "f32oorx", detail: "f32oorx $aDst0 $aSrc0", documentation: "Floating-point reciprocal of square-root\n" },
  CompletionDef { label: "f32oox", detail: "f32oox $aDst0 $aSrc0", documentation: "Floating-point reciprocal\n" },
  CompletionDef { label: "f32sigm", detail: "f32sigm $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f32sisoamp", detail: "f32sisoamp $aDst0:Dst0+1 $aSrc0 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* floating-point vector accumulating matrix-vector\nproduct\n" },
  CompletionDef { label: "f32sisoslic", detail: "f32sisoslic $aDst0:Dst0+1 $aSrc0 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* floating-point slim convolution\n" },
  CompletionDef { label: "f32sisov2amp", detail: "f32sisov2amp $aDst0:Dst0+1 $aSrc0 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* floating-point vector accumulating matrix-vector\nproduct\n" },
  CompletionDef { label: "f32sisov2slic", detail: "f32sisov2slic $aDst0:Dst0+1 $aSrc0 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* floating-point slim convolution\n" },
  CompletionDef { label: "f32sqrt", detail: "f32sqrt $aDst0 $aSrc0", documentation: "Single precision square root\n" },
  CompletionDef { label: "f32sub", detail: "f32sub $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point subtract\n" },
  CompletionDef { label: "f32sufromui", detail: "f32sufromui $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f32tanh", detail: "f32tanh $aDst0 $aSrc0", documentation: "*Single-precision* floating-point hyperbolic tangent\n" },
  CompletionDef { label: "f32tof16", detail: "f32tof16 $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f32toi32", detail: "f32toi32 $aDst0 $aSrc0", documentation: "*Single-precision* floating-point to signed integer conversion\n" },
  CompletionDef { label: "f32toui32", detail: "f32toui32 $aDst0 $aSrc0", documentation: "*Single-precision* floating-point to unsigned integer conversion\n" },
  CompletionDef { label: "f32v2absadd", detail: "f32v2absadd $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* floating-point vector add of absolutes\n" },
  CompletionDef { label: "f32v2absmax", detail: "f32v2absmax $aDst0:Dst0+1 $aSrc1:Src1+1 $aSrc0:Src0+1", documentation: "*Single-precision* vector max of absolute values\n" },
  CompletionDef { label: "f32v2add", detail: "f32v2add $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector add\n" },
  CompletionDef { label: "f32v2aop", detail: "f32v2aop $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* vector accumulating outer-product\n" },
  CompletionDef { label: "f32v2axpy", detail: "f32v2axpy $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* 2-element vector z = ax + y\n" },
  CompletionDef { label: "f32v2clamp", detail: "f32v2clamp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* floating-point vector min-of-maximum\n" },
  CompletionDef { label: "f32v2class", detail: "f32v2class $aDst0 $aSrc0:Src0+1", documentation: "*Single-precision* floating-point vector classifier\n" },
  CompletionDef { label: "f32v2cmpeq", detail: "f32v2cmpeq $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector equality test\n" },
  CompletionDef { label: "f32v2cmpge", detail: "f32v2cmpge $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector greater-than or equal-to test\n" },
  CompletionDef { label: "f32v2cmpgt", detail: "f32v2cmpgt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector greater-than test\n" },
  CompletionDef { label: "f32v2cmple", detail: "f32v2cmple $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector less-than or equal-to test\n" },
  CompletionDef { label: "f32v2cmplt", detail: "f32v2cmplt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector less-than test\n" },
  CompletionDef { label: "f32v2cmpne", detail: "f32v2cmpne $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector inequality test\n" },
  CompletionDef { label: "f32v2gina", detail: "f32v2gina $aDst0:Dst0+1 $aSrc0:Src0+1 zimm12", documentation: "Get and initialise accumulators\n" },
  CompletionDef { label: "f32v2grand", detail: "f32v2grand $aDst0:Dst0+1", documentation: "Gaussian distribution, 2-element *single-precision* random vector\n" },
  CompletionDef { label: "f32v2mac", detail: "f32v2mac $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector multiply and accumulate\n" },
  CompletionDef { label: "f32v2max", detail: "f32v2max $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector max\n" },
  CompletionDef { label: "f32v2min", detail: "f32v2min $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector min\n" },
  CompletionDef { label: "f32v2mul", detail: "f32v2mul $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector Hadamard product\n" },
  CompletionDef { label: "f32v2rmask", detail: "f32v2rmask $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1", documentation: "*Single-precision* vector random mask\n" },
  CompletionDef { label: "f32v2sub", detail: "f32v2sub $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector subtraction\n" },
  CompletionDef { label: "f32v2sufromui", detail: "f32v2sufromui $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "\n" },
  CompletionDef { label: "f32v2tof16", detail: "f32v2tof16 $aDst0 $aSrc0:Src0+1", documentation: "*Single-precision* pair to *f16* pair\n" },
  CompletionDef { label: "f32v4absacc", detail: "f32v4absacc $aSrc0:Src0+3", documentation: "*Single-precision* vector accumulation of absolutes\n" },
  CompletionDef { label: "f32v4acc", detail: "f32v4acc $aSrc0:Src0+3", documentation: "*Single-precision* vector accumulate\n" },
  CompletionDef { label: "f32v4sqacc", detail: "f32v4sqacc $aSrc0:Src0+3", documentation: "*Single-precision* vector accumulate squares\n" },
  CompletionDef { label: "f32v4tof16", detail: "f32v4tof16 $aDst0:Dst0+1 $aSrc0:Src0+3", documentation: "*Single-precision* 4-element vector to *f16* vector\n" },
  CompletionDef { label: "fnop", detail: "fnop", documentation: "`fnop`\n\nDo nothing for one cycle (aux pipeline). Alias for `or $azero, $azero, 0`\n" },
  CompletionDef { label: "get", detail: "get $mDst0 zimm8", documentation: "Lower control register read\n" },
  CompletionDef { label: "ld128", detail: "ld128 $aDst0:Dst0+3 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "Single 128-bit load from interleaved memory region\n" },
  CompletionDef { label: "ld128putcs", detail: "ld128putcs zimm8", documentation: "128-bit load and put to common configuration space\n" },
  CompletionDef { label: "ld128step", detail: "ld128step $aDst0:Dst0+3 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing 128-bit load from interleaved memory region.\n" },
  CompletionDef { label: "ld2x64pace", detail: "ld2x64pace $aDst0:Dst0+1 $aDst1:Dst1+1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing, dual 64-bit load\n" },
  CompletionDef { label: "ld2xst64pace", detail: "ld2xst64pace $aDst0:Dst0+3 $aSrc0:Src0+1 $mAddr0:Addr0+1+= $mStride0 Strimm3x2", documentation: "Post-incrementing dual 64-bit load with simultaneous 64-bit store.\n" },
  CompletionDef { label: "ld32", detail: "ld32 $mDst0 $mBase0 $mDelta0 $mOff0 (and 3 more)", documentation: "Single 32-bit load\n" },
  CompletionDef { label: "ld32step", detail: "ld32step $mDst0 $mBase0 $mDelta0+= simm8 (and 3 more)", documentation: "Post-incrementing *word* load\n" },
  CompletionDef { label: "ld64", detail: "ld64 $aDst0:Dst0+1 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "Single 64-bit load\n" },
  CompletionDef { label: "ld64a32", detail: "ld64a32 $aDst0+1:Dst0+3 $mAddr0++ $mBase0 $mDelta0", documentation: "Post-incrementing dense 64-bit plus sparse 32-bit load\n" },
  CompletionDef { label: "ld64a32pace", detail: "ld64a32pace $aDst0:Dst0+1 $aDst1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing dual 64/32-bit load\n" },
  CompletionDef { label: "ld64b16pace", detail: "ld64b16pace $aDst0:Dst0+1 $aDst1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing, dual 64/16-bit load\n" },
  CompletionDef { label: "ld64putcs", detail: "ld64putcs zimm8", documentation: "64-bit load and put to common configuration space\n" },
  CompletionDef { label: "ld64step", detail: "ld64step $aDst0:Dst0+1 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing 64-bit load\n" },
  CompletionDef { label: "ldb16", detail: "ldb16 $aDst0 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "16-bit load and broadcast\n" },
  CompletionDef { label: "ldb16b16", detail: "ldb16b16 $aDst0:Dst0+1 $mBase0 $mDelta0++ $mMiniD0&gt;&gt;", documentation: "Post-incrementing, lightly-sparse 16-bit with dense 16-bit load\n" },
  CompletionDef { label: "ldb16step", detail: "ldb16step $aDst0 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing 16-bit load and broadcast\n" },
  CompletionDef { label: "ldconst", detail: "ldconst $mDest zimm (and 2 more)", documentation: "Load a constant into a register. This can be used to load 32-bit constants which takes two actual instructions. This compiles to `setzi` instructions.\n" },
  CompletionDef { label: "ldd16a32", detail: "ldd16a32 $aDst0 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing 16-bit delta and 32-bit data load\n" },
  CompletionDef { label: "ldd16a64", detail: "ldd16a64 $aDst0:Dst0+1 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing 16-bit delta and 64-bit data load\n" },
  CompletionDef { label: "ldd16b16", detail: "ldd16b16 $aDst0 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing 16-bit delta and broadcast 16-bit data load\n" },
  CompletionDef { label: "ldd16v2a32", detail: "ldd16v2a32 $aDst0 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing delta-pair plus 32-bit load\n" },
  CompletionDef { label: "lds16", detail: "lds16 $mDst0 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "Sign extending 16-bit load\n" },
  CompletionDef { label: "lds16step", detail: "lds16step $mDst0 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing sign-extending 16-bit load\n" },
  CompletionDef { label: "lds8", detail: "lds8 $mDst0 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "Sign extending 8-bit load\n" },
  CompletionDef { label: "lds8step", detail: "lds8step $mDst0 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing sign-extending 8-bit load\n" },
  CompletionDef { label: "ldst64pace", detail: "ldst64pace $aDst0:Dst0+1 $aSrc0:Src0+1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing 64-bit load with simultaneous 64-bit store.\n" },
  CompletionDef { label: "ldz16", detail: "ldz16 $mDst0 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "Zero-extending 16-bit load\n" },
  CompletionDef { label: "ldz16step", detail: "ldz16step $mDst0 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing zero-extending 16-bit load\n" },
  CompletionDef { label: "ldz8", detail: "ldz8 $mDst0 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "Zero-extending 8-bit load\n" },
  CompletionDef { label: "ldz8step", detail: "ldz8step $mDst0 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing *zero extended* 8-bit load\n" },
  CompletionDef { label: "max", detail: "max $mDst0 $mSrc0 $mSrc1 (and 2 more)", documentation: "Maximum\n" },
  CompletionDef { label: "min", detail: "min $mDst0 $mSrc0 $mSrc1 (and 2 more)", documentation: "Minimum\n" },
  CompletionDef { label: "mov", detail: "mov $mDest $mSrc (and 2 more)", documentation: "Copy the value in `$mSrc` to `mDst`. This compiles to `or` or `atom` instructions.\n" },
  CompletionDef { label: "movz", detail: "movz $mSrcDst0 $mSrc0 $mSrc1", documentation: "Conditional move\n" },
  CompletionDef { label: "mul", detail: "mul $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "Signed multiplication\n" },
  CompletionDef { label: "nop", detail: "nop", documentation: "Do nothing for one cycle (main pipeline). Alias for `or $mzero, $mzero, 0`\n" },
  CompletionDef { label: "not", detail: "not $aDst0 $aSrc0", documentation: "32-bit bitwise logical NOT\n" },
  CompletionDef { label: "not128", detail: "not128 $aDst0:Dst0+3 $aSrc0:Src0+3", documentation: "128-bit bitwise logical NOT\n" },
  CompletionDef { label: "not64", detail: "not64 $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "64-bit bitwise logical NOT\n" },
  CompletionDef { label: "or", detail: "or $mDst0 $mSrc0 $mSrc1 (and 5 more)", documentation: "Bitwise OR\n" },
  CompletionDef { label: "or64", detail: "or64 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "64-bit bitwise logical OR\n" },
  CompletionDef { label: "popc", detail: "popc $mDst0 $mSrc0", documentation: "Population count\n" },
  CompletionDef { label: "put", detail: "put zimm8 $mSrc0", documentation: "Write to a lower control register\n" },
  CompletionDef { label: "roll16", detail: "roll16 $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "roll16 SIMD permutation\n" },
  CompletionDef { label: "roll32", detail: "roll32 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "roll32 SIMD permutation\n" },
  CompletionDef { label: "roll8l", detail: "roll8l $mDst0 $mSrc0 $mSrc1", documentation: "roll8-left SIMD permutation\n" },
  CompletionDef { label: "roll8r", detail: "roll8r $mDst0 $mSrc0 $mSrc1", documentation: "roll8-right SIMD permutation\n" },
  CompletionDef { label: "rpt", detail: "rpt $mSrc0 zimm8 (and 1 more)", documentation: "Repeat a sequence of *Execution Bundle*s\n" },
  CompletionDef { label: "run", detail: "run $mEntry0 $mVBase0 zimm16", documentation: "Launch a worker thread\n" },
  CompletionDef { label: "runall", detail: "runall $mEntry0 $mVBase0 zimm16", documentation: "Launch a batch of worker threads\n" },
  CompletionDef { label: "setzi", detail: "setzi $mDst0 zimm20 (and 1 more)", documentation: "Register set from immediate\n" },
  CompletionDef { label: "shl", detail: "shl $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "Logical shift left\n" },
  CompletionDef { label: "shr", detail: "shr $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "Logical shift right\n" },
  CompletionDef { label: "shrs", detail: "shrs $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "Signed (arithmetic) shift right\n" },
  CompletionDef { label: "shuf8x8hi", detail: "shuf8x8hi $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n" },
  CompletionDef { label: "shuf8x8lo", detail: "shuf8x8lo $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n" },
  CompletionDef { label: "sort4x16hi", detail: "sort4x16hi $mDst0 $mSrc0 $mSrc1 (and 2 more)", documentation: "4 x 16-bit SIMD permutation\n" },
  CompletionDef { label: "sort4x16lo", detail: "sort4x16lo $mDst0 $mSrc0 $mSrc1 (and 2 more)", documentation: "4 x 16-bit SIMD permutation\n" },
  CompletionDef { label: "sort4x32hi", detail: "sort4x32hi $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "4 x 32-bit SIMD permutation\n" },
  CompletionDef { label: "sort4x32lo", detail: "sort4x32lo $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "4 x 32-bit SIMD permutation\n" },
  CompletionDef { label: "sort8", detail: "sort8 $mDst0 $mSrc0", documentation: "4 x 8-bit SIMD permutation\n" },
  CompletionDef { label: "sort8x8hi", detail: "sort8x8hi $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n" },
  CompletionDef { label: "sort8x8lo", detail: "sort8x8lo $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n" },
  CompletionDef { label: "st32", detail: "st32 $aSrc0 $mBase0 $mDelta0 $mOffset0 (and 2 more)", documentation: "32-bit store\n" },
  CompletionDef { label: "st32step", detail: "st32step $mSrc0 $mBase0 $mDelta0+= simm8 (and 2 more)", documentation: "Post-incrementing 32-bit store\n" },
  CompletionDef { label: "st64", detail: "st64 $aSrc0:Src0+1 $mBase0 $mDelta0 $mOffset0 (and 1 more)", documentation: "64-bit store\n" },
  CompletionDef { label: "st64pace", detail: "st64pace $aSrc0:Src0+1 $mAddr0:Addr0+1+= $mStride0 Strimm2", documentation: "Post-incrementing 64-bit store, using packed addresses and offsets\n" },
  CompletionDef { label: "st64step", detail: "st64step $aSrc0:Src0+1 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing 64-bit store\n" },
  CompletionDef { label: "stm32", detail: "stm32 $mSrc0 $mBase0 $mOffset0", documentation: "32-bit store from MRF\n" },
  CompletionDef { label: "stm32step", detail: "stm32step $mSrc0 $mBase0+= $mStride0", documentation: "Post-incrementing 32-bit store from MRF\n" },
  CompletionDef { label: "sub", detail: "sub $mDst0 $mSrc1 $mSrc0 (and 2 more)", documentation: "Subtraction\n" },
  CompletionDef { label: "swap8", detail: "swap8 $mDst0 $mSrc0", documentation: "4 x 8-bit SIMD permutation\n" },
  CompletionDef { label: "tapack", detail: "tapack $mDst0:Dst0+1 $mAddr0 $mAddr1 $mAddr2", documentation: "Triple address pack\n" },
  CompletionDef { label: "trap", detail: "trap zimm4", documentation: "Patched BREAKPOINT\n" },
  CompletionDef { label: "uget", detail: "uget $aDst0 zimm8", documentation: "Upper control register read\n" },
  CompletionDef { label: "uput", detail: "uput zimm8 $aSrc0", documentation: "Write to an upper control register\n" },
  CompletionDef { label: "urand32", detail: "urand32 $aDst0", documentation: "Uniform distribution, 32-bit random integer\n" },
  CompletionDef { label: "urand64", detail: "urand64 $aDst0:Dst0+1", documentation: "Uniform distribution, 64-bit random integer\n" },
  CompletionDef { label: "xnor", detail: "xnor $mDst0 $mSrc0 $mSrc1", documentation: "Bitwise NOT XOR\n" },
  CompletionDef { label: "xor", detail: "xor $mDst0 $mSrc0 $mSrc1", documentation: "Bitwise XOR\n" },
  CompletionDef { label: "zero", detail: "zero $mDest (and 2 more)", documentation: "Zero the register. Alias for `or $mDest, $mzero, 0`, `or $aDest, $azero, 0` or `or64 $aDest:1, $azeros, 0`.\n" },
];
pub static COMPLETION_RANGES: phf::Map<&'static str, std::ops::Range<usize>> = ::phf::Map {
    key: 12913932095322966823,
    disps: &[
        (0, 8),
        (0, 203),
        (0, 9),
        (0, 0),
        (0, 69),
        (0, 8),
        (0, 1),
        (0, 4),
        (0, 174),
        (0, 1),
        (0, 106),
        (0, 319),
        (0, 31),
        (0, 26),
        (0, 1021),
        (0, 495),
        (0, 2),
        (0, 27),
        (0, 70),
        (0, 2),
        (0, 0),
        (0, 60),
        (0, 436),
        (0, 456),
        (0, 1),
        (0, 3),
        (0, 181),
        (0, 441),
        (0, 2),
        (0, 253),
        (0, 41),
        (0, 8),
        (0, 278),
        (0, 487),
        (0, 634),
        (0, 182),
        (0, 0),
        (0, 0),
        (0, 204),
        (0, 414),
        (0, 50),
        (0, 2),
        (0, 512),
        (0, 1),
        (0, 398),
        (0, 127),
        (1, 184),
        (0, 24),
        (0, 5),
        (0, 502),
        (0, 13),
        (0, 519),
        (0, 284),
        (0, 115),
        (0, 499),
        (0, 284),
        (0, 1),
        (0, 2),
        (0, 488),
        (0, 50),
        (0, 15),
        (0, 205),
        (0, 1),
        (0, 52),
        (0, 33),
        (0, 90),
        (0, 134),
        (0, 0),
        (0, 225),
        (0, 437),
        (0, 300),
        (0, 340),
        (0, 416),
        (0, 6),
        (0, 23),
        (0, 10),
        (0, 1074),
        (0, 523),
        (0, 125),
        (0, 208),
        (4, 237),
        (0, 0),
        (0, 99),
        (0, 202),
        (0, 4),
        (0, 240),
        (0, 0),
        (0, 15),
        (1, 460),
        (0, 11),
        (0, 427),
        (0, 600),
        (0, 0),
        (0, 30),
        (1, 621),
        (0, 6),
        (0, 20),
        (0, 608),
        (2, 22),
        (1, 896),
        (0, 203),
        (0, 14),
        (0, 147),
        (1, 122),
        (1, 347),
        (0, 33),
        (0, 234),
        (0, 15),
        (0, 4),
        (0, 185),
        (0, 4),
        (0, 980),
        (1, 882),
        (0, 123),
        (0, 178),
        (0, 545),
        (0, 201),
        (0, 812),
        (0, 0),
        (0, 70),
        (0, 12),
        (0, 488),
        (0, 128),
        (0, 378),
        (0, 401),
        (0, 17),
        (0, 0),
        (0, 631),
        (0, 17),
        (0, 363),
        (0, 29),
        (0, 706),
        (0, 196),
        (0, 430),
        (0, 71),
        (0, 267),
        (0, 543),
        (0, 0),
        (2, 478),
        (2, 133),
        (0, 6),
        (0, 848),
        (0, 8),
        (0, 7),
        (0, 31),
        (0, 57),
        (1, 610),
        (0, 18),
        (0, 1036),
        (0, 421),
        (0, 172),
        (0, 719),
        (0, 666),
        (0, 164),
        (0, 654),
        (0, 0),
        (0, 451),
        (0, 0),
        (0, 341),
        (2, 204),
        (0, 81),
        (0, 598),
        (0, 554),
        (3, 651),
        (0, 11),
        (1, 549),
        (1, 123),
        (0, 1),
        (0, 796),
        (1, 898),
        (0, 51),
        (0, 8),
        (1, 968),
        (1, 3),
        (0, 2),
        (0, 21),
        (1, 156),
        (0, 13),
        (0, 547),
        (0, 23),
        (0, 3),
        (1, 522),
        (0, 33),
        (1, 418),
        (2, 618),
        (0, 18),
        (9, 874),
        (8, 941),
        (0, 280),
        (0, 0),
        (0, 101),
        (0, 0),
        (0, 14),
        (0, 26),
        (0, 907),
        (0, 0),
        (0, 138),
        (0, 4),
        (0, 106),
        (0, 12),
        (0, 14),
        (0, 4),
        (6, 683),
        (0, 78),
        (0, 351),
        (15, 1016),
        (2, 996),
        (0, 229),
        (0, 591),
        (1, 995),
        (0, 286),
        (0, 0),
        (1, 395),
        (0, 432),
        (0, 401),
        (0, 133),
        (0, 60),
        (0, 45),
        (0, 659),
        (0, 72),
        (0, 503),
        (0, 616),
        (4, 254),
        (0, 248),
        (0, 141),
    ],
    entries: &[
        ("f32v2abs", 220..222),
        ("f32add", 185..186),
        ("ge", 248..249),
        ("$DBG_ECL", 9..10),
        ("f32int", 199..200),
        ("f16v4su", 177..180),
        ("$INCOMING_DCOUNT", 22..23),
        ("$VERTEX", 48..49),
        ("f16v4sihos", 173..174),
        ("ld2", 252..254),
        ("f16v4sih", 172..174),
        ("$OUTGOING_BA", 28..29),
        ("f16v2l", 134..136),
        ("$PRNG_0_0", 31..32),
        ("f16v4sihoa", 172..173),
        ("lds16s", 271..272),
        ("f32v2mi", 237..238),
        ("f32sisoamp", 209..210),
        ("$WORKER_", 49..50),
        ("f16v4c", 151..160),
        ("$INCOMING_MUXPAIR", 26..27),
        ("f1", 117..183),
        ("f32d", 194..195),
        ("f32v2suf", 241..242),
        ("tapac", 321..322),
        ("$mvertex_base", 86..87),
        ("st3", 312..314),
        ("f32v2ao", 223..224),
        ("f16v4sisos", 175..176),
        ("f16v4sihosli", 173..174),
        ("$COU", 2..4),
        ("$m1", 71..78),
        ("sort4x16h", 305..306),
        ("$WORKER_BASE", 49..50),
        ("f16v4suf", 178..179),
        ("$mver", 86..87),
        ("f16v2cmpg", 125..127),
        ("cl", 107..108),
        ("c", 106..113),
        ("sort", 305..312),
        ("$DBG_BRK_ID", 6..7),
        ("$DBG_IOWNER", 12..13),
        ("$CCCSLOAD", 1..2),
        ("f16v4clas", 152..153),
        ("$INCOMING_BAS", 21..22),
        ("lds", 270..275),
        ("$INCOMING_DCO", 22..23),
        ("f16v4sihoslic", 173..174),
        ("f32v4absacc", 243..244),
        ("mu", 283..284),
        ("$mvertex_ba", 86..87),
        ("ld64b16pace", 259..260),
        ("ld64a32", 257..259),
        ("shuf8x8", 303..305),
        ("$mve", 86..87),
        ("$EXCH", 15..17),
        ("f16v4ma", 166..168),
        ("f32absa", 183..184),
        ("f16v2s", 140..144),
        ("st64pace", 315..316),
        ("f16v4hihoamp", 161..162),
        ("f32tanh", 216..217),
        ("$DBG_IEXEC", 11..12),
        ("$W", 49..52),
        ("f16v4ad", 150..151),
        ("f16tof3", 117..118),
        ("f16v4cmpeq", 154..155),
        ("$DBG_RBRK_", 14..15),
        ("$INCOMING_FORM", 24..25),
        ("$TDI_C", 44..46),
        ("f32absma", 184..185),
        ("$SC", 39..41),
        ("exit", 113..117),
        ("ug", 323..324),
        ("$INCOMING_M", 25..27),
        ("p", 290..292),
        ("$WORKER_B", 49..50),
        ("f16v2si", 140..141),
        ("$a6", 63..65),
        ("rp", 296..297),
        ("$INCOMING_FOR", 24..25),
        ("f32log2", 201..202),
        ("f16v4min", 168..169),
        ("no", 284..288),
        ("f16v4sub", 177..178),
        ("$WORKER", 49..51),
        ("f16v4hihov4", 163..165),
        ("f16tof32", 117..118),
        ("f32v2absad", 220..221),
        ("f16v4siho", 172..174),
        ("$WORKER_BA", 49..50),
        ("ldd16a64", 267..268),
        ("urand32", 325..326),
        ("f16to", 117..118),
        ("$FP", 17..21),
        ("$WORKER{0}_BAS", 50..51),
        ("f16v4sufr", 178..179),
        ("brnz", 101..103),
        ("$OU", 28..30),
        ("$CCCSLOA", 1..2),
        ("f32tan", 216..217),
        ("$DBG_RB", 13..15),
        ("$INCOMING_FORMAT", 24..25),
        ("bitrev8", 97..98),
        ("f16v2gi", 132..133),
        ("ld128step", 251..252),
        ("$WORKER{", 50..51),
        ("brneg", 100..101),
        ("$INC", 21..28),
        ("f32v2cmple", 230..231),
        ("f16v4g", 160..161),
        ("$ANS_DCO", 0..1),
        ("$EXCHANGE_C", 16..17),
        ("$TDI_ST", 46..47),
        ("cmpn", 109..110),
        ("f16v8sqacc", 182..183),
        ("f32sq", 213..214),
        ("f16v4gac", 160..161),
        ("f16v4sihosl", 173..174),
        ("ld2x64pa", 252..253),
        ("$s", 89..90),
        ("$REPEAT_END", 37..38),
        ("lds16step", 271..272),
        ("not64", 287..288),
        ("st64p", 315..316),
        ("$REPEAT_COU", 36..37),
        ("$CTXT_", 5..6),
        ("f32cmpl", 191..193),
        ("f16v4absma", 148..149),
        ("f32mu", 205..206),
        ("$FP_STS", 20..21),
        ("$INCOMING_DCOUN", 22..23),
        ("$PRNG_1_", 33..35),
        ("$CTXT_STS", 5..6),
        ("ldd16b16", 268..269),
        ("$REPEAT_EN", 37..38),
        ("f16v2sufro", 142..143),
        ("shuf8x", 303..305),
        ("sort4x16hi", 305..306),
        ("ld64a32pace", 258..259),
        ("ld128pu", 250..251),
        ("f16v2cl", 121..123),
        ("ldb16b16", 263..264),
        ("f32cmpe", 188..189),
        ("f32absad", 183..184),
        ("f32mul", 205..206),
        ("brzdec", 105..106),
        ("mul", 283..284),
        ("xno", 327..328),
        ("f32v4tof", 246..247),
        ("f32ex", 195..197),
        ("xor", 328..329),
        ("bit", 97..98),
        ("$ANS_DC", 0..1),
        ("f32i", 199..200),
        ("f32v4acc", 244..245),
        ("f32class", 187..188),
        ("f16v4istacc", 165..166),
        ("bi", 97..98),
        ("brnzd", 102..103),
        ("ld32st", 255..256),
        ("pu", 291..292),
        ("f16v4hiho", 161..165),
        ("$VER", 48..49),
        ("ld64pu", 260..261),
        ("$az", 66..68),
        ("stm32step", 318..319),
        ("f16v2tanh", 144..145),
        ("$mvertex_b", 86..87),
        ("ldb16s", 264..265),
        ("ld64a32pac", 258..259),
        ("f32toui", 219..220),
        ("f16v4cmpg", 155..157),
        ("f32fromi3", 197..198),
        ("$FP_", 17..21),
        ("f32v2cmpge", 228..229),
        ("$REPEAT_F", 38..39),
        ("f16v4stac", 176..177),
        ("f16v4r", 171..172),
        ("$EXCHANGE_CT", 16..17),
        ("f16v2ab", 118..120),
        ("ldz16s", 276..277),
        ("ld64ste", 261..262),
        ("f16", 117..183),
        ("st64pac", 315..316),
        ("ab", 90..91),
        ("ldd16v2", 269..270),
        ("$SNOTIFY", 41..42),
        ("$a4", 60..62),
        ("f32ab", 183..185),
        ("$INCOMING_FO", 24..25),
        ("f32v2cmplt", 231..232),
        ("$a15", 56..57),
        ("uput", 324..325),
        ("f16v8acc", 181..182),
        ("shl", 300..301),
        ("f32cmpge", 189..190),
        ("f32v2absma", 221..222),
        ("$DBG_RBRK_VER", 14..15),
        ("f16v4a", 146..151),
        ("f32v2gi", 233..234),
        ("sort8", 309..312),
        ("f32sisosli", 210..211),
        ("f16v2log", 135..136),
        ("$INCOMING_DELTA", 23..24),
        ("$CR", 4..5),
        ("$FP_CLR", 17..18),
        ("ld2x64", 252..253),
        ("f16v4st", 176..177),
        ("f32v4ab", 243..244),
        ("$O", 28..30),
        ("brnzde", 102..103),
        ("ldb16b", 263..264),
        ("$ANS_D", 0..1),
        ("$OUTGOING_", 28..30),
        ("$WORKER{0}_B", 50..51),
        ("setz", 299..300),
        ("xo", 328..329),
        ("swap8", 320..321),
        ("f32lo", 201..202),
        ("f32div", 194..195),
        ("f16v2tan", 144..145),
        ("sort8x", 310..312),
        ("exitpos", 115..116),
        ("ato", 96..97),
        ("$CCC", 1..2),
        ("f16v4sisoam", 174..175),
        ("$REPEAT_C", 36..37),
        ("$WSR", 51..52),
        ("$DBG_", 6..15),
        ("f32sisov2amp", 211..212),
        ("$PRNG_0_", 31..33),
        ("ldz8st", 278..279),
        ("f16v4stacc", 176..177),
        ("$m9", 85..86),
        ("$OUTGOING", 28..30),
        ("f16v2absm", 119..120),
        ("$lr", 69..70),
        ("f32v2sufrom", 241..242),
        ("f32sub", 214..215),
        ("f32clam", 186..187),
        ("ldz16step", 276..277),
        ("$DBG_B", 6..7),
        ("f32fromui32", 198..199),
        ("f16v4absm", 148..149),
        ("ldcons", 265..266),
        ("$INCOMI", 21..28),
        ("$INCOM", 21..28),
        ("mi", 280..281),
        ("stm32s", 318..319),
        ("f16v2cmpne", 129..130),
        ("f16v2clamp", 121..122),
        ("f32ln", 200..201),
        ("ld64b16pa", 259..260),
        ("s", 299..321),
        ("ze", 329..330),
        ("$mvertex", 86..87),
        ("stm3", 317..319),
        ("f16v2cla", 121..123),
        ("brzde", 105..106),
        ("$TDI_CTL", 45..46),
        ("f32cmp", 188..194),
        ("$T", 43..48),
        ("f32v", 220..247),
        ("f32t", 216..220),
        ("rol", 292..296),
        ("f16v8absacc", 180..181),
        ("tapa", 321..322),
        ("stm32ste", 318..319),
        ("r", 292..299),
        ("$SN", 41..42),
        ("cmpsl", 110..111),
        ("$DBG_BRK_I", 6..7),
        ("f32cmpne", 193..194),
        ("mo", 281..283),
        ("f32v2rm", 239..240),
        ("$SNO", 41..42),
        ("f16v2abs", 118..120),
        ("lds16st", 271..272),
        ("$a7", 65..66),
        ("a", 90..97),
        ("ldb16ste", 264..265),
        ("f16v4cma", 153..154),
        ("$A", 0..1),
        ("$mvertex_bas", 86..87),
        ("f16v4hihov4slic", 164..165),
        ("$TILE_ID", 47..48),
        ("$OUTG", 28..30),
        ("f32a", 183..186),
        ("lds8st", 273..274),
        ("f32v2cmpn", 232..233),
        ("ld2xst64pace", 253..254),
        ("f16v4sisosli", 175..176),
        ("f16v2exp", 130..132),
        ("not12", 286..287),
        ("$F", 17..21),
        ("sort4x16l", 306..307),
        ("f32clamp", 186..187),
        ("f16v4h", 161..165),
        ("fno", 247..248),
        ("ldz16ste", 276..277),
        ("f32ad", 185..186),
        ("$REPEAT_FI", 38..39),
        ("f32cmplt", 192..193),
        ("exitpo", 115..116),
        ("ldd16a3", 266..267),
        ("f32v2cmpl", 230..232),
        ("$DBG_R", 13..15),
        ("f16v4sisosl", 175..176),
        ("f32su", 214..216),
        ("f16v4cl", 151..153),
        ("ld64putc", 260..261),
        ("f32toui3", 219..220),
        ("$m7", 83..84),
        ("ld", 249..279),
        ("f32v4absa", 243..244),
        ("$DBG_IO", 12..13),
        ("runa", 298..299),
        ("sort8x8l", 311..312),
        ("f32v4t", 246..247),
        ("f16v4ista", 165..166),
        ("$INCOMING_FORMA", 24..25),
        ("f16v4max", 166..168),
        ("f16v2cmpn", 129..130),
        ("f32f", 197..199),
        ("$INCOMING_BASE", 21..22),
        ("ldb1", 262..265),
        ("bitrev", 97..98),
        ("f32tou", 219..220),
        ("$DBG_RBRK_VE", 14..15),
        ("f32oo", 206..208),
        ("$DBG_CT", 7..8),
        ("f32v2s", 240..242),
        ("$WOR", 49..51),
        ("f16v2absmax", 119..120),
        ("f32v2g", 233..235),
        ("f16v2cmpgt", 126..127),
        ("ldz1", 275..277),
        ("ld2x64p", 252..253),
        ("f32o", 206..208),
        ("f32v2sufr", 241..242),
        ("$OUTGOING_B", 28..29),
        ("ldst6", 274..275),
        ("ldco", 265..266),
        ("f16v4absad", 147..148),
        ("$REPEAT", 36..39),
        ("f16v2sigm", 140..141),
        ("sort4x16", 305..307),
        ("$m8", 84..85),
        ("st64", 314..317),
        ("$a4:", 61..62),
        ("$DBG_RBR", 13..15),
        ("$TDI_S", 46..47),
        ("f16v4sis", 174..176),
        ("f32v2cmpgt", 229..230),
        ("ld2x64pac", 252..253),
        ("f16v8sqac", 182..183),
        ("f16v8s", 182..183),
        ("f32v2r", 239..240),
        ("lds8step", 273..274),
        ("f32m", 202..206),
        ("f32sisov2sl", 212..213),
        ("f32from", 197..199),
        ("setzi", 299..300),
        ("$CO", 2..4),
        ("roll16", 292..293),
        ("st6", 314..317),
        ("f32v4sqacc", 245..246),
        ("f32exp2", 196..197),
        ("zer", 329..330),
        ("f32sisoam", 209..210),
        ("$DBG_RBRK_V", 14..15),
        ("ld128p", 250..251),
        ("f32sisoa", 209..210),
        ("ldb16", 262..265),
        ("roll8l", 294..295),
        ("tap", 321..322),
        ("an", 92..96),
        ("o", 288..290),
        ("ld128putc", 250..251),
        ("f16v4sisoslic", 175..176),
        ("xnor", 327..328),
        ("st", 312..319),
        ("mov", 281..283),
        ("brpos", 103..104),
        ("$DBG_DA", 8..9),
        ("f32v2axpy", 224..225),
        ("$CTXT", 5..6),
        ("f16v8absac", 180..181),
        ("$DB", 6..15),
        ("$D", 6..15),
        ("$PRNG_0", 31..33),
        ("ld2x", 252..254),
        ("ldcon", 265..266),
        ("$INCOMING_DELT", 23..24),
        ("$a14", 55..56),
        ("$DBG_ECLR", 9..10),
        ("cmpslt", 110..111),
        ("f16v4sihoam", 172..173),
        ("$a5", 62..63),
        ("runall", 298..299),
        ("f16v4siso", 174..176),
        ("f16v4rmas", 171..172),
        ("$COUN", 2..4),
        ("$mw", 87..88),
        ("$COUNT", 2..4),
        ("sort8x8", 310..312),
        ("brn", 100..103),
        ("u", 323..327),
        ("$FP_CTL", 18..19),
        ("$mvert", 86..87),
        ("$AN", 0..1),
        ("ld128putcs", 250..251),
        ("ldd16b1", 268..269),
        ("$WORKER_BAS", 49..50),
        ("br", 98..106),
        ("roll8", 294..296),
        ("exitn", 113..115),
        ("f16v2g", 132..134),
        ("f32v2clamp", 225..226),
        ("call", 106..107),
        ("f32v2tof16", 242..243),
        ("$azero", 66..68),
        ("f16v4hihosl", 162..163),
        ("b", 97..106),
        ("roll32", 293..294),
        ("$CTX", 5..6),
        ("$IN", 21..28),
        ("f16v2sum", 143..144),
        ("f32v2absa", 220..221),
        ("$WORKER{0}_BA", 50..51),
        ("$m6", 82..83),
        ("f16v2cmple", 127..128),
        ("ld32step", 255..256),
        ("f32max", 203..204),
        ("f16v2cmpeq", 124..125),
        ("bitr", 97..98),
        ("f16v2m", 136..140),
        ("f32fromui", 198..199),
        ("f16v2gina", 132..133),
        ("f16v2", 118..146),
        ("f16v4cmple", 157..158),
        ("f32v2mul", 238..239),
        ("$mworker_ba", 87..88),
        ("$DBG_I", 11..13),
        ("f32absm", 184..185),
        ("swap", 320..321),
        ("fnop", 247..248),
        ("f32absadd", 183..184),
        ("f32v4", 243..247),
        ("f16v4sufro", 178..179),
        ("brp", 103..104),
        ("$REPEAT_COUNT", 36..37),
        ("f32v2cmpeq", 227..228),
        ("f32v4absac", 243..244),
        ("$DBG_IEXE", 11..12),
        ("f16v4maxc", 167..168),
        ("$TI", 47..48),
        ("f32v2tof1", 242..243),
        ("f32abs", 183..185),
        ("sw", 320..321),
        ("f32min", 204..205),
        ("$DBG_IOWN", 12..13),
        ("$INCOMING_SI", 27..28),
        ("$", 0..90),
        ("f32v2aop", 223..224),
        ("$m3", 79..80),
        ("f16v4", 146..180),
        ("f32v2axp", 224..225),
        ("$WORKER{0}", 50..51),
        ("atom", 96..97),
        ("exitnz", 114..115),
        ("$REPEAT_FIRS", 38..39),
        ("$OUTGOING_D", 29..30),
        ("f3", 183..247),
        ("$mwor", 87..88),
        ("f16v2grand", 133..134),
        ("$FP_S", 20..21),
        ("$DBG_D", 8..9),
        ("not128", 286..287),
        ("$FP_ICT", 19..20),
        ("f16v2sufromu", 142..143),
        ("$a2", 57..59),
        ("$INCOMING_D", 22..24),
        ("$DBG_IEX", 11..12),
        ("ldconst", 265..266),
        ("ld2x6", 252..253),
        ("f32toi3", 218..219),
        ("f16v2mul", 139..140),
        ("ta", 321..322),
        ("$a2:3", 58..59),
        ("f16v4absadd", 147..148),
        ("roll3", 293..294),
        ("f16v2gr", 133..134),
        ("f16v4s", 172..180),
        ("$PRNG_", 31..36),
        ("st32ste", 313..314),
        ("f16v4clam", 151..152),
        ("f32v2cla", 225..227),
        ("ura", 325..327),
        ("f32e", 195..197),
        ("f16v4add", 150..151),
        ("$CCCSL", 1..2),
        ("f16v4hihosli", 162..163),
        ("sort4", 305..309),
        ("f32siso", 209..213),
        ("se", 299..300),
        ("cmpne", 109..110),
        ("lds1", 270..272),
        ("ld32s", 255..256),
        ("sort8x8hi", 310..311),
        ("and", 92..96),
        ("$R", 36..39),
        ("$DBG_IOW", 12..13),
        ("f32cmpn", 193..194),
        ("$SCOUNT_", 39..41),
        ("f32fromi", 197..198),
        ("f32oor", 206..207),
        ("f32", 183..247),
        ("f16v2tof32", 145..146),
        ("f32mi", 204..205),
        ("$a0:", 53..54),
        ("sort4x32l", 308..309),
        ("$WORKE", 49..51),
        ("$azeros", 67..68),
        ("f32v2sufro", 241..242),
        ("shrs", 302..303),
        ("tr", 322..323),
        ("$DBG_C", 7..8),
        ("$a4:5", 61..62),
        ("$mworker_", 87..88),
        ("f32sufromu", 215..216),
        ("f16v4ab", 146..149),
        ("$CCCSLO", 1..2),
        ("ldst64pace", 274..275),
        ("f16v2su", 141..144),
        ("$DBG_BRK", 6..7),
        ("f32ma", 202..204),
        ("$a1", 54..57),
        ("$TILE", 47..48),
        ("brzd", 105..106),
        ("n", 284..288),
        ("$TILE_", 47..48),
        ("f16v4hihos", 162..163),
        ("x", 327..329),
        ("f16v2gran", 133..134),
        ("f32cm", 188..194),
        ("$OUTGOING_BASE", 28..29),
        ("$INCO", 21..28),
        ("add", 91..92),
        ("not1", 286..287),
        ("$INCOMING_MU", 25..27),
        ("popc", 290..291),
        ("f32v4sq", 245..246),
        ("f16v4hihov4a", 163..164),
        ("ldz16", 275..277),
        ("ca", 106..107),
        ("f16v2cmac", 123..124),
        ("$ANS_DCOU", 0..1),
        ("$VERT", 48..49),
        ("f16v4cmpe", 154..155),
        ("f16v4sta", 176..177),
        ("ld64step", 261..262),
        ("f32v2cmpne", 232..233),
        ("$m12", 74..75),
        ("f16v4hihoslic", 162..163),
        ("ld32", 254..256),
        ("f32sufromui", 215..216),
        ("$CTXT_S", 5..6),
        ("$I", 21..28),
        ("$WORK", 49..51),
        ("$OUTGOING_DELT", 29..30),
        ("$ANS_", 0..1),
        ("$INCOMING_B", 21..22),
        ("$DBG_DATA", 8..9),
        ("f16v2clam", 121..122),
        ("sort4x32", 307..309),
        ("$VERTEX_B", 48..49),
        ("f32sisov2a", 211..212),
        ("f32v2clam", 225..226),
        ("f16v2cm", 123..130),
        ("f32v4tof16", 246..247),
        ("ldz8ste", 278..279),
        ("$EXCHANG", 15..17),
        ("f32v2cmp", 227..233),
        ("sort4x32hi", 307..308),
        ("shuf8x8h", 303..304),
        ("f32v2to", 242..243),
        ("f16v4rmask", 171..172),
        ("cm", 108..113),
        ("ld64putcs", 260..261),
        ("f32v4sqac", 245..246),
        ("f32fromu", 198..199),
        ("movz", 282..283),
        ("$mworker", 87..88),
        ("st64step", 316..317),
        ("f32v2mac", 235..236),
        ("cmpeq", 108..109),
        ("brpo", 103..104),
        ("f16v2mu", 139..140),
        ("f32v2cmpg", 228..230),
        ("$FP_C", 17..19),
        ("f16v4hihov4sl", 164..165),
        ("$PRNG", 31..36),
        ("max", 279..280),
        ("f16tof", 117..118),
        ("cal", 106..107),
        ("f16v4hihov4amp", 163..164),
        ("$m15", 77..78),
        ("$SCOUNT_L", 39..40),
        ("f32si", 208..213),
        ("shuf8x8hi", 303..304),
        ("$REPEA", 36..39),
        ("$INCOMING_BA", 21..22),
        ("ld64st", 261..262),
        ("put", 291..292),
        ("f16v2cmpe", 124..125),
        ("$DBG_BRK_", 6..7),
        ("f32to", 217..220),
        ("ldd1", 266..270),
        ("f32v4ac", 244..245),
        ("f16v2ex", 130..132),
        ("f16v2log2", 135..136),
        ("f16v4cmpl", 157..159),
        ("$a", 52..68),
        ("m", 279..284),
        ("$REP", 36..39),
        ("f16v4gacc", 160..161),
        ("abs", 90..91),
        ("urand6", 326..327),
        ("stm32st", 318..319),
        ("f16v2sufromui", 142..143),
        ("brne", 100..101),
        ("pop", 290..291),
        ("f16v4absac", 146..147),
        ("f16v4sufromu", 178..179),
        ("$a0", 52..54),
        ("f16v4mu", 170..171),
        ("$ANS_DCOUNT", 0..1),
        ("ld2xst64p", 253..254),
        ("$OUTGOING_DEL", 29..30),
        ("f32fromi32", 197..198),
        ("f32v4s", 245..246),
        ("f16v4sufrom", 178..179),
        ("ld128put", 250..251),
        ("$DBG_EC", 9..11),
        ("f16v2gin", 132..133),
        ("f32toi", 218..219),
        ("fn", 247..248),
        ("$EXCHA", 15..17),
        ("f16v8abs", 180..181),
        ("exitp", 115..116),
        ("$PRNG_SE", 35..36),
        ("f16v4cmpgt", 156..157),
        ("$WO", 49..51),
        ("f16v2tof3", 145..146),
        ("$ANS", 0..1),
        ("$PRNG_S", 35..36),
        ("f16v4hih", 161..165),
        ("f32cmpgt", 190..191),
        ("shuf8x8l", 304..305),
        ("f16v4sufromui", 178..179),
        ("po", 290..291),
        ("ldst64pa", 274..275),
        ("$PC", 30..31),
        ("f32sigm", 208..209),
        ("ldz8", 277..279),
        ("f32v2su", 240..242),
        ("f16v2mi", 138..139),
        ("$INCOMING", 21..28),
        ("f16v2cma", 123..124),
        ("ld2xs", 253..254),
        ("exitneg", 113..114),
        ("f32toui32", 219..220),
        ("cmps", 110..111),
        ("f32v2cl", 225..227),
        ("ldz16st", 276..277),
        ("$mworker_bas", 87..88),
        ("$FP_I", 19..20),
        ("ld64p", 260..261),
        ("$SSR", 42..43),
        ("f32sisov2slic", 212..213),
        ("$m5", 81..82),
        ("f16v2e", 130..132),
        ("andc64", 95..96),
        ("f16v2suf", 142..143),
        ("$mzero", 88..89),
        ("$WS", 51..52),
        ("f32v2sub", 240..241),
        ("clz", 107..108),
        ("$mze", 88..89),
        ("lds8ste", 273..274),
        ("$f", 68..69),
        ("ld64b1", 259..260),
        ("not", 285..288),
        ("ld64b16", 259..260),
        ("ldd16a32", 266..267),
        ("$a6:7", 64..65),
        ("urand64", 326..327),
        ("$a6:", 64..65),
        ("$EXCHANGE_ADJ", 15..16),
        ("$VERTEX_BA", 48..49),
        ("f32oox", 207..208),
        ("f16v8a", 180..182),
        ("$C", 1..6),
        ("f16v2c", 121..130),
        ("$TDI_CT", 45..46),
        ("f16v4cmac", 153..154),
        ("$CTXT_ST", 5..6),
        ("$PRNG_1", 33..35),
        ("$SCOUN", 39..41),
        ("$l", 69..70),
        ("ld2x64pace", 252..253),
        ("f32cl", 186..188),
        ("ld64a32pa", 258..259),
        ("f16v8", 180..183),
        ("$WORKER{0", 50..51),
        ("f16v2cmpl", 127..129),
        ("upu", 324..325),
        ("f16v4rma", 171..172),
        ("f16v4cmpne", 159..160),
        ("ldst64pac", 274..275),
        ("f32clas", 187..188),
        ("$mz", 88..89),
        ("f16v4cm", 153..160),
        ("l", 249..279),
        ("$mworke", 87..88),
        ("$OUTGOING_DE", 29..30),
        ("ld2xst64", 253..254),
        ("$COUNT_L", 2..3),
        ("$INCOMING_", 21..28),
        ("$mwork", 87..88),
        ("e", 113..117),
        ("trap", 322..323),
        ("$WORKER{0}_", 50..51),
        ("ldz", 275..279),
        ("f16v2min", 138..139),
        ("sort4x32h", 307..308),
        ("f16v4clamp", 151..152),
        ("at", 96..97),
        ("f", 117..248),
        ("f16v4hihoa", 161..162),
        ("f32v2absm", 221..222),
        ("ldst", 274..275),
        ("ldst64p", 274..275),
        ("ex", 113..117),
        ("$TDI_CL", 44..45),
        ("cms", 112..113),
        ("$m13", 75..76),
        ("sort8x8h", 310..311),
        ("$PRN", 31..36),
        ("f32cmpg", 189..191),
        ("stm32", 317..319),
        ("f32v2mu", 238..239),
        ("f32v2cm", 227..233),
        ("f32sufrom", 215..216),
        ("bitre", 97..98),
        ("f16v8sqa", 182..183),
        ("$EXCHAN", 15..17),
        ("f16v2absa", 118..119),
        ("f32oorx", 206..207),
        ("f32sig", 208..209),
        ("$DBG", 6..15),
        ("lds8s", 273..274),
        ("$mworker_base", 87..88),
        ("f32sisov2s", 212..213),
        ("f16v2cmplt", 128..129),
        ("$TDI_STS", 46..47),
        ("$SNOT", 41..42),
        ("exi", 113..117),
        ("f16v2ma", 136..138),
        ("ldst64", 274..275),
        ("f16v4cmpge", 155..156),
        ("ld2xst64pac", 253..254),
        ("ldb", 262..265),
        ("$a0:1", 53..54),
        ("$azer", 66..68),
        ("f16v4hihov4sli", 164..165),
        ("$TDI", 44..47),
        ("f32v2ad", 222..223),
        ("ldc", 265..266),
        ("andc6", 95..96),
        ("$SS", 42..43),
        ("f32v2class", 226..227),
        ("$m14", 76..77),
        ("$m", 70..89),
        ("$mverte", 86..87),
        ("$DBG_IOWNE", 12..13),
        ("$mvertex_", 86..87),
        ("$mv", 86..87),
        ("$m10", 72..73),
        ("f32v2sufromui", 241..242),
        ("sort8x8lo", 311..312),
        ("f32tof16", 217..218),
        ("ldd16b", 268..269),
        ("f16v2max", 136..138),
        ("f16v4ist", 165..166),
        ("$WORKER{0}_BASE", 50..51),
        ("f16v2absadd", 118..119),
        ("f16v2a", 118..121),
        ("f16v2t", 144..146),
        ("$OUT", 28..30),
        ("f16v2tof", 145..146),
        ("f32v2c", 225..233),
        ("f32log", 201..202),
        ("$FP_CT", 18..19),
        ("ldd", 266..270),
        ("$COUNT_U", 3..4),
        ("f16v4m", 166..171),
        ("f32sisov2am", 211..212),
        ("sort4x3", 307..309),
        ("$DBG_IE", 11..12),
        ("f32sisosl", 210..211),
        ("ld128", 249..252),
        ("swa", 320..321),
        ("not6", 287..288),
        ("f32sisov", 211..213),
        ("f16v4ac", 149..150),
        ("$VERTEX_", 48..49),
        ("f32cla", 186..188),
        ("ld12", 249..252),
        ("f32v2ab", 220..222),
        ("ld2xst", 253..254),
        ("sort4x32lo", 308..309),
        ("f16v2ln", 134..135),
        ("$OUTGOING_BAS", 28..29),
        ("f32tof1", 217..218),
        ("f32c", 186..194),
        ("$DBG_RBRK", 13..15),
        ("f32v2rmas", 239..240),
        ("f32v2max", 236..237),
        ("brnzdec", 102..103),
        ("ld64", 256..262),
        ("$INCOMING_MUX", 25..27),
        ("f16v2lo", 135..136),
        ("f16v2clas", 122..123),
        ("f16v4abs", 146..149),
        ("f16v4ga", 160..161),
        ("st32step", 313..314),
        ("$PR", 31..36),
        ("$VERTEX_BASE", 48..49),
        ("$PRNG_SEED", 35..36),
        ("$INCOMING_MUXP", 26..27),
        ("$DBG_E", 9..11),
        ("$SCO", 39..41),
        ("uran", 325..327),
        ("or", 288..290),
        ("ld128st", 251..252),
        ("ld64b", 259..260),
        ("lds8", 272..274),
        ("ldd16a", 266..268),
        ("$INCOMING_S", 27..28),
        ("f32v2", 220..243),
        ("shuf8", 303..305),
        ("cmpe", 108..109),
        ("cmp", 108..112),
        ("shu", 303..305),
        ("shuf8x8lo", 304..305),
        ("urand3", 325..326),
        ("$EXCHANGE_AD", 15..16),
        ("f16t", 117..118),
        ("f16v4hihov4am", 163..164),
        ("cmpu", 111..112),
        ("ldb16st", 264..265),
        ("f32v2sufromu", 241..242),
        ("$mworker_b", 87..88),
        ("f16v2sig", 140..141),
        ("f16v4sum", 179..180),
        ("$INCOMIN", 21..28),
        ("$EX", 15..17),
        ("f32toi32", 218..219),
        ("f32sqrt", 213..214),
        ("$REPEAT_FIR", 38..39),
        ("$INCOMING_F", 24..25),
        ("st32st", 313..314),
        ("f16v8sq", 182..183),
        ("ru", 297..299),
        ("f16v8absa", 180..181),
        ("$REPEAT_CO", 36..37),
        ("$DBG_ECS", 10..11),
        ("xn", 327..328),
        ("$m0", 70..71),
        ("z", 329..330),
        ("f16v4hihov4s", 164..165),
        ("f32l", 200..202),
        ("$REPEAT_E", 37..38),
        ("f32suf", 215..216),
        ("ldz8s", 278..279),
        ("ld64b16p", 259..260),
        ("$INCOMING_DCOU", 22..23),
        ("cmpul", 111..112),
        ("$REPEAT_FIRST", 38..39),
        ("f32v2a", 220..225),
        ("f32fr", 197..199),
        ("and6", 93..94),
        ("up", 324..325),
        ("ldb16b1", 263..264),
        ("f16v4sisoamp", 174..175),
        ("f32v2add", 222..223),
        ("f32v2absmax", 221..222),
        ("$sp", 89..90),
        ("f16v2absma", 119..120),
        ("f32v2gina", 233..234),
        ("$SCOU", 39..41),
        ("sor", 305..312),
        ("$OUTGO", 28..30),
        ("$FP_IC", 19..20),
        ("ad", 91..92),
        ("min", 280..281),
        ("f16v2maxc", 137..138),
        ("f32sisov2sli", 212..213),
        ("f16v4absa", 146..148),
        ("f16v2ta", 144..145),
        ("zero", 329..330),
        ("$CC", 1..2),
        ("f32ta", 216..217),
        ("$ANS_DCOUN", 0..1),
        ("f16v4sihoamp", 172..173),
        ("$DBG_BR", 6..7),
        ("$TILE_I", 47..48),
        ("$TDI_", 44..47),
        ("f32v2tof", 242..243),
        ("$m11", 73..74),
        ("f32v2gin", 233..234),
        ("ldd16a6", 267..268),
        ("f16v8ac", 181..182),
        ("f32cmpeq", 188..189),
        ("ld1", 249..252),
        ("$INCOMING_DEL", 23..24),
        ("$TA", 43..44),
        ("f32v2clas", 226..227),
        ("f16v2cmpge", 125..126),
        ("$TIL", 47..48),
        ("ld3", 254..256),
        ("shuf", 303..305),
        ("run", 297..299),
        ("$SNOTIF", 41..42),
        ("f32sisoslic", 210..211),
        ("f16v4i", 165..166),
        ("$aze", 66..68),
        ("f16v4class", 152..153),
        ("roll8r", 295..296),
        ("$m2", 78..79),
        ("$E", 15..17),
        ("ldb16step", 264..265),
        ("lds16", 270..272),
        ("f16v4hi", 161..165),
        ("f16v2class", 122..123),
        ("$S", 39..43),
        ("$INCOMING_DE", 23..24),
        ("and64", 93..94),
        ("f16v4mi", 168..170),
        ("f32v2gra", 234..235),
        ("g", 248..249),
        ("exitne", 113..114),
        ("f16v4cla", 151..153),
        ("$PRNG_1_0", 33..34),
        ("$TAS", 43..44),
        ("$VERTE", 48..49),
        ("ld128ste", 251..252),
        ("set", 299..300),
        ("$PRNG_1_1", 34..35),
        ("f32sufro", 215..216),
        ("f32exp", 195..197),
        ("sh", 300..305),
        ("f32in", 199..200),
        ("ldd16v2a3", 269..270),
        ("sub", 319..320),
        ("$INCOMING_MUXPA", 26..27),
        ("st32", 312..314),
        ("$INCOMING_SIN", 27..28),
        ("ldd16v2a32", 269..270),
        ("f16v2sufrom", 142..143),
        ("$INCOMING_DC", 22..23),
        ("$SCOUNT_U", 40..41),
        ("urand", 325..327),
        ("f16v4acc", 149..150),
        ("$EXCHANGE_", 15..17),
        ("sort4x16lo", 306..307),
        ("f32s", 208..216),
        ("f32v2min", 237..238),
        ("f32v2t", 242..243),
        ("$fp", 68..69),
        ("$FP_CL", 17..18),
        ("f16v4cmpn", 159..160),
        ("f16v2to", 145..146),
        ("f16v2absad", 118..119),
        ("ld64a32p", 258..259),
        ("$mzer", 88..89),
        ("st64st", 316..317),
        ("f16v", 118..183),
        ("$REPE", 36..39),
        ("$REPEAT_COUN", 36..37),
        ("$DBG_ECSR", 10..11),
        ("$EXCHANGE_CTL", 16..17),
        ("ld6", 256..262),
        ("f32v4sqa", 245..246),
        ("or6", 289..290),
        ("$a2:", 58..59),
        ("$RE", 36..39),
        ("ldd16", 266..270),
        ("su", 319..320),
        ("ld2xst64pa", 253..254),
        ("f32v2cmpe", 227..228),
        ("ld32ste", 255..256),
        ("$PRNG_0_1", 32..33),
        ("rpt", 296..297),
        ("f32v2rma", 239..240),
        ("$TD", 44..47),
        ("f32v4to", 246..247),
        ("$SCOUNT", 39..41),
        ("f32cmple", 191..192),
        ("ld64put", 260..261),
        ("st32s", 313..314),
        ("f32v2m", 235..239),
        ("f32v4tof1", 246..247),
        ("exitz", 116..117),
        ("ld64a", 257..259),
        ("ldd16v2a", 269..270),
        ("shr", 301..303),
        ("$OUTGOING_DELTA", 29..30),
        ("get", 248..249),
        ("f32sufr", 215..216),
        ("f16v4sisoa", 174..175),
        ("f16v2sufr", 142..143),
        ("$INCOMING_MUXPAI", 26..27),
        ("f16v4cmplt", 158..159),
        ("andc", 94..96),
        ("ld2xst6", 253..254),
        ("f16v4mul", 170..171),
        ("f16v8ab", 180..181),
        ("roll", 292..296),
        ("f16v4hihov", 163..165),
        ("stm", 317..319),
        ("f16v4mix", 169..170),
        ("nop", 284..285),
        ("$DBG_CTL", 7..8),
        ("ld128s", 251..252),
        ("f32v2gr", 234..235),
        ("$SNOTI", 41..42),
        ("f16v4rm", 171..172),
        ("ldd16v", 269..270),
        ("f32sqr", 213..214),
        ("f16v2gra", 133..134),
        ("tapack", 321..322),
        ("$P", 30..36),
        ("f32sisov2", 211..213),
        ("$VE", 48..49),
        ("$INCOMING_SINIT", 27..28),
        ("f16v2exp2", 131..132),
        ("tra", 322..323),
        ("uget", 323..324),
        ("so", 305..312),
        ("f16v2sub", 141..142),
        ("f32mac", 202..203),
        ("t", 321..323),
        ("ma", 279..280),
        ("$TDI_CLR", 44..45),
        ("$DBG_DAT", 8..9),
        ("$OUTGOIN", 28..30),
        ("f32v4a", 243..245),
        ("bri", 99..100),
        ("$a3", 59..60),
        ("$OUTGOI", 28..30),
        ("f32fromui3", 198..199),
        ("f16v4cmp", 154..160),
        ("ro", 292..296),
        ("f32tof", 217..218),
        ("lds16ste", 271..272),
        ("f32absmax", 184..185),
        ("f16v2cmp", 124..130),
        ("$CT", 5..6),
        ("f16v4absmax", 148..149),
        ("f32v2grand", 234..235),
        ("sort4x", 305..309),
        ("$m4", 80..81),
        ("f32v2rmask", 239..240),
        ("st64pa", 315..316),
        ("sort4x1", 305..307),
        ("$mwo", 87..88),
        ("ld64s", 261..262),
        ("$VERTEX_BAS", 48..49),
        ("runal", 298..299),
        ("$PRNG_SEE", 35..36),
        ("$V", 48..49),
        ("f16v2ad", 120..121),
        ("ld64b16pac", 259..260),
        ("st64ste", 316..317),
        ("uge", 323..324),
        ("f32v2ax", 224..225),
        ("or64", 289..290),
        ("f16v4absacc", 146..147),
        ("ldz8step", 278..279),
        ("f32fro", 197..199),
        ("f16v4is", 165..166),
        ("f16v2add", 120..121),
        ("f32v2absadd", 220..221),
        ("$FP_ICTL", 19..20),
        ("f16v4si", 172..176),
        ("f16v4hihoam", 161..162),
        ("$EXCHANGE_A", 15..16),
        ("$INCOMING_SINI", 27..28),
        ("$COUNT_", 2..4),
        ("f32v4abs", 243..244),
        ("f32v2gran", 234..235),
        ("cmpult", 111..112),
        ("ld64a3", 257..259),
        ("f32di", 194..195),
        ("brz", 104..106),
        ("f32v2ma", 235..237),
        ("st64s", 316..317),
        ("$REPEAT_", 36..39),
        ("f32sis", 209..213),
        ("ur", 325..327),
        ("$FP_ST", 20..21),
        ("$CCCS", 1..2),
        ("f32sisos", 210..211),
        ("$EXC", 15..17),
        ("f16v4istac", 165..166),
        ("roll1", 292..293),
        ("$EXCHANGE", 15..17),
        ("$DBG_RBRK_VERT", 14..15),
    ],
};

pub struct SignatureDef<'a> {
    pub label: &'a str,
    pub documentation: &'a str,
    pub parameters: &'a [SignatureParam<'a>],
}

pub struct SignatureParam<'a> {
    pub label: &'a str,
    pub documentation: &'a str,
}

pub static SIGNATURES: phf::Map<&'static str, &'static [SignatureDef<'static>]> = ::phf::Map {
    key: 12913932095322966823,
    disps: &[
        (0, 1),
        (0, 27),
        (0, 58),
        (0, 133),
        (0, 23),
        (0, 4),
        (0, 43),
        (2, 212),
        (2, 154),
        (0, 18),
        (0, 26),
        (6, 148),
        (0, 0),
        (0, 155),
        (1, 24),
        (0, 2),
        (0, 62),
        (0, 34),
        (0, 0),
        (6, 156),
        (1, 194),
        (12, 114),
        (0, 8),
        (0, 155),
        (0, 0),
        (0, 12),
        (0, 3),
        (0, 39),
        (0, 167),
        (0, 0),
        (6, 43),
        (0, 72),
        (0, 168),
        (9, 63),
        (0, 9),
        (8, 17),
        (0, 17),
        (0, 0),
        (0, 152),
        (43, 115),
        (164, 1),
        (0, 1),
        (8, 139),
        (0, 8),
        (0, 195),
        (3, 18),
        (3, 104),
    ],
    entries: &[
        ("f16v4max", &[SignatureDef { label: "f16v4max $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector max\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32toi32", &[SignatureDef { label: "f32toi32 $aDst0 $aSrc0", documentation: "*Single-precision* floating-point to signed integer conversion\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("brnz", &[SignatureDef { label: "brnz $mSrc0 zimm19", documentation: "Branch if not zero\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("ldz8", &[SignatureDef { label: "ldz8 $mDst0 $mBase0 $mDelta0 $mOff0", documentation: "Zero-extending 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ldz8 $mDst0 $mBase0 $mDelta0 zimm12", documentation: "Zero-extending 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f32v4tof16", &[SignatureDef { label: "f32v4tof16 $aDst0:Dst0+1 $aSrc0:Src0+3", documentation: "*Single-precision* 4-element vector to *f16* vector\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("lds16step", &[SignatureDef { label: "lds16step $mDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing sign-extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "lds16step $mDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing sign-extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("f16v4absadd", &[SignatureDef { label: "f16v4absadd $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector addition of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("get", &[SignatureDef { label: "get $mDst0 zimm8", documentation: "Lower control register read\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "zimm8", documentation: "" }, ] }, ]),
        ("f32tanh", &[SignatureDef { label: "f32tanh $aDst0 $aSrc0", documentation: "*Single-precision* floating-point hyperbolic tangent\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4min", &[SignatureDef { label: "f16v4min $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector minimum\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v4class", &[SignatureDef { label: "f16v4class $aDst0 $aSrc0:Src0+1", documentation: "*Half-precision* floating-point vector classifier\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("f32ln", &[SignatureDef { label: "f32ln $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4stacc", &[SignatureDef { label: "f16v4stacc $aDst0:Dst0+1 enumFlags", documentation: "Sort/shuffle (permute) through accumulators (no new input)\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f32log2", &[SignatureDef { label: "f32log2 $aDst0 $aSrc0", documentation: "Base 2 logarithm\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("andc", &[SignatureDef { label: "andc $mDst0 $mSrc0 $mSrc1", documentation: "32-bit bitwise logical AND Complement\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "andc $mDst0 $mSrc0 zimm12", documentation: "32-bit bitwise logical AND Complement\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "andc $aDst0 $aSrc0 $aSrc1", documentation: "32-bit bitwise logical AND Complement\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "andc $aDst0 $aSrc0 zimm12", documentation: "32-bit bitwise logical AND Complement\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "andc $aDst0 $aSrc0 immz12", documentation: "32-bit bitwise logical AND Complement\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "immz12", documentation: "" }, ] }, ]),
        ("xor", &[SignatureDef { label: "xor $mDst0 $mSrc0 $mSrc1", documentation: "Bitwise XOR\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("clz", &[SignatureDef { label: "clz $mDst0 $mSrc0", documentation: "Count leading zero bits\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f16v2sum", &[SignatureDef { label: "f16v2sum $aDst0 $aSrc0", documentation: "*Half-precision* vector lateral summation\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32exp", &[SignatureDef { label: "f32exp $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32cmpeq", &[SignatureDef { label: "f32cmpeq $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v4add", &[SignatureDef { label: "f16v4add $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector addition\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4add $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector addition\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4add $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector addition\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v4cmple", &[SignatureDef { label: "f16v4cmple $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector less-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmple $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector less-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmple $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector less-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ld32", &[SignatureDef { label: "ld32 $mDst0 $mBase0 $mDelta0 $mOff0", documentation: "Single 32-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ld32 $aDst0 $mBase0 $mDelta0 $mOff0", documentation: "Single 32-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ld32 $mDst0 $mBase0 $mDelta0 zimm12", documentation: "Single 32-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "ld32 $aDst0 $mBase0 $mDelta0 zimm12", documentation: "Single 32-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f16v4acc", &[SignatureDef { label: "f16v4acc $aSrc0:Src0+1", documentation: "*Half-precision* vector accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("runall", &[SignatureDef { label: "runall $mEntry0 $mVBase0 zimm16", documentation: "Launch a batch of worker threads\n\n\n", parameters: &[SignatureParam { label: "$mEntry0", documentation: "" }, SignatureParam { label: "$mVBase0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, ]),
        ("f16v2max", &[SignatureDef { label: "f16v2max $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector max\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2tof32", &[SignatureDef { label: "f16v2tof32 $aDst0:Dst0+1 $aSrc0", documentation: "*f16* pair to *single-precision* pair\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("shl", &[SignatureDef { label: "shl $mDst0 $mSrc0 $mSrc1", documentation: "Logical shift left\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "shl $mDst0 $mSrc0 zimm12", documentation: "Logical shift left\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f16v4sisoslic", &[SignatureDef { label: "f16v4sisoslic $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*f16* slim convolution\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f32mul", &[SignatureDef { label: "f32mul $aDst0 $aSrc0 $aSrc1", documentation: "Single precision floating-point multiply\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2cmple", &[SignatureDef { label: "f16v2cmple $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector less-than-or-equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmple $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector less-than-or-equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmple $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector less-than-or-equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v8sqacc", &[SignatureDef { label: "f16v8sqacc $aSrc0:Src0+3", documentation: "*Half-precision* vector accumulate squares\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("f32fromi32", &[SignatureDef { label: "f32fromi32 $aDst0 $aSrc0", documentation: "Signed integer to :term:\\'single-precision\\` floating-point conversion\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32cmpge", &[SignatureDef { label: "f32cmpge $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point greater than or equal test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v4cmpgt", &[SignatureDef { label: "f16v4cmpgt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpgt $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpgt $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ldd16b16", &[SignatureDef { label: "ldd16b16 $aDst0 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing 16-bit delta and broadcast 16-bit data load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mAddr0++", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0@", documentation: "" }, ] }, ]),
        ("f32sufromui", &[SignatureDef { label: "f32sufromui $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("stm32step", &[SignatureDef { label: "stm32step $mSrc0 $mBase0+= $mStride0", documentation: "Post-incrementing 32-bit store from MRF\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mBase0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("urand32", &[SignatureDef { label: "urand32 $aDst0", documentation: "Uniform distribution, 32-bit random integer\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, ] }, ]),
        ("sort8", &[SignatureDef { label: "sort8 $mDst0 $mSrc0", documentation: "4 x 8-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f32int", &[SignatureDef { label: "f32int $aDst0 $aSrc1 enumRnd", documentation: "round to integral\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, SignatureParam { label: "enumRnd", documentation: "" }, ] }, ]),
        ("f16v2mul", &[SignatureDef { label: "f16v2mul $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* 2-element vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2mul $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* 2-element vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2mul $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* 2-element vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("cmpslt", &[SignatureDef { label: "cmpslt $mDst0 $mSrc0 $mSrc1", documentation: "Signed less-than test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "cmpslt $mDst0 $mSrc0 simm16", documentation: "Signed less-than test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, ] }, ]),
        ("ldd16a32", &[SignatureDef { label: "ldd16a32 $aDst0 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing 16-bit delta and 32-bit data load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mAddr0++", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0@", documentation: "" }, ] }, ]),
        ("f32v2rmask", &[SignatureDef { label: "f32v2rmask $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1", documentation: "*Single-precision* vector random mask\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v4cmpeq", &[SignatureDef { label: "f16v4cmpeq $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpeq $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpeq $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("swap8", &[SignatureDef { label: "swap8 $mDst0 $mSrc0", documentation: "4 x 8-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("lds16", &[SignatureDef { label: "lds16 $mDst0 $mBase0 $mDelta0 $mOff0", documentation: "Sign extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "lds16 $mDst0 $mBase0 $mDelta0 zimm12", documentation: "Sign extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f16v2clamp", &[SignatureDef { label: "f16v2clamp $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector min-of-maximum\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32absadd", &[SignatureDef { label: "f32absadd $aDst0 $aSrc0 $aSrc1", documentation: "Scalar floating-point addition of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2class", &[SignatureDef { label: "f16v2class $aDst0 $aSrc0", documentation: "*Half-precision* floating-point vector classifier\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32sisoslic", &[SignatureDef { label: "f32sisoslic $aDst0:Dst0+1 $aSrc0 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* floating-point slim convolution\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f32v2cmpeq", &[SignatureDef { label: "f32v2cmpeq $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2cmpeq $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32cmple", &[SignatureDef { label: "f32cmple $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point less or equal\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("sort8x8lo", &[SignatureDef { label: "sort8x8lo $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("trap", &[SignatureDef { label: "trap zimm4", documentation: "Patched BREAKPOINT\n\n\n", parameters: &[SignatureParam { label: "zimm4", documentation: "" }, ] }, ]),
        ("shuf8x8lo", &[SignatureDef { label: "shuf8x8lo $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("roll16", &[SignatureDef { label: "roll16 $mDst0 $mSrc0 $mSrc1", documentation: "roll16 SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "roll16 $aDst0 $aSrc0 $aSrc1", documentation: "roll16 SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("cmpne", &[SignatureDef { label: "cmpne $mDst0 $mSrc0 $mSrc1", documentation: "Inequality test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("f32v2grand", &[SignatureDef { label: "f32v2grand $aDst0:Dst0+1", documentation: "Gaussian distribution, 2-element *single-precision* random vector\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, ] }, ]),
        ("f32sisov2slic", &[SignatureDef { label: "f32sisov2slic $aDst0:Dst0+1 $aSrc0 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* floating-point slim convolution\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("rpt", &[SignatureDef { label: "rpt $mSrc0 zimm8", documentation: "Repeat a sequence of *Execution Bundle*s\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm8", documentation: "" }, ] }, SignatureDef { label: "rpt zimm12 zimm8", documentation: "Repeat a sequence of *Execution Bundle*s\n\n\n", parameters: &[SignatureParam { label: "zimm12", documentation: "" }, SignatureParam { label: "zimm8", documentation: "" }, ] }, ]),
        ("f16v4sub", &[SignatureDef { label: "f16v4sub $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector subtraction\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4sub $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector subtraction\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4sub $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector subtraction\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("andc64", &[SignatureDef { label: "andc64 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "64-bit bitwise logical AND Complement\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32v4acc", &[SignatureDef { label: "f32v4acc $aSrc0:Src0+3", documentation: "*Single-precision* vector accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("shrs", &[SignatureDef { label: "shrs $mDst0 $mSrc0 $mSrc1", documentation: "Signed (arithmetic) shift right\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "shrs $mDst0 $mSrc0 zimm12", documentation: "Signed (arithmetic) shift right\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("ldz8step", &[SignatureDef { label: "ldz8step $mDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing *zero extended* 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ldz8step $mDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing *zero extended* 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("brz", &[SignatureDef { label: "brz $mSrc0 zimm19", documentation: "Branch if zero\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("bitrev8", &[SignatureDef { label: "bitrev8 $mDst0 $mSrc0", documentation: "Byte-wise bit order reversal\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("and64", &[SignatureDef { label: "and64 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "64-bit bitwise logical AND\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ld64b16pace", &[SignatureDef { label: "ld64b16pace $aDst0:Dst0+1 $aDst1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing, dual 64/16-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aDst1", documentation: "" }, SignatureParam { label: "$mAddr0:Addr0+1+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, SignatureParam { label: "Strimm2x2", documentation: "" }, ] }, ]),
        ("f16v4sihoamp", &[SignatureDef { label: "f16v4sihoamp $aDst0 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Half-precision* floating-point vector accumulating matrix-vector\nproduct\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("st32step", &[SignatureDef { label: "st32step $mSrc0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing 32-bit store\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "st32step $aSrc0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing 32-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "st32step $aSrc0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing 32-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("f16v2absadd", &[SignatureDef { label: "f16v2absadd $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector add of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("tapack", &[SignatureDef { label: "tapack $mDst0:Dst0+1 $mAddr0 $mAddr1 $mAddr2", documentation: "Triple address pack\n\n\n", parameters: &[SignatureParam { label: "$mDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mAddr0", documentation: "" }, SignatureParam { label: "$mAddr1", documentation: "" }, SignatureParam { label: "$mAddr2", documentation: "" }, ] }, ]),
        ("bri", &[SignatureDef { label: "bri zimm19", documentation: "Unconditional absolute branch to immediate target\n\n\n", parameters: &[SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("f32v2add", &[SignatureDef { label: "f32v2add $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector add\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2add $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector add\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("brzdec", &[SignatureDef { label: "brzdec $mSrcDst0 zimm19", documentation: "Branch if zero, with counter decrement\n\n\n", parameters: &[SignatureParam { label: "$mSrcDst0", documentation: "" }, SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("xnor", &[SignatureDef { label: "xnor $mDst0 $mSrc0 $mSrc1", documentation: "Bitwise NOT XOR\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("run", &[SignatureDef { label: "run $mEntry0 $mVBase0 zimm16", documentation: "Launch a worker thread\n\n\n", parameters: &[SignatureParam { label: "$mEntry0", documentation: "" }, SignatureParam { label: "$mVBase0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, ]),
        ("f32clamp", &[SignatureDef { label: "f32clamp $aDst0 $aSrc0 $aSrc1:Src1+1", documentation: "*Single-precision* floating-point vector min-of-maximum\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32v2clamp", &[SignatureDef { label: "f32v2clamp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* floating-point vector min-of-maximum\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v2sufromui", &[SignatureDef { label: "f16v2sufromui $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("stm32", &[SignatureDef { label: "stm32 $mSrc0 $mBase0 $mOffset0", documentation: "32-bit store from MRF\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mOffset0", documentation: "" }, ] }, ]),
        ("exitnz", &[SignatureDef { label: "exitnz $mSrc0", documentation: "Worker thread termination\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f16v2log2", &[SignatureDef { label: "f16v2log2 $aDst0 $aSrc0", documentation: "*Half-precision* floating-point vector base 2 logarithm\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32v2mac", &[SignatureDef { label: "f32v2mac $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector multiply and accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("lds8step", &[SignatureDef { label: "lds8step $mDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing sign-extending 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "lds8step $mDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing sign-extending 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("f16v4cmpge", &[SignatureDef { label: "f16v4cmpge $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector greater-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpge $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector greater-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpge $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector greater-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v4cmplt", &[SignatureDef { label: "f16v4cmplt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmplt $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmplt $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("exitneg", &[SignatureDef { label: "exitneg $mSrc0", documentation: "Worker thread termination\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f32v2cmple", &[SignatureDef { label: "f32v2cmple $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector less-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2cmple $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector less-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32add", &[SignatureDef { label: "f32add $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point addition\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2maxc", &[SignatureDef { label: "f16v2maxc $aDst0 $aSrc0", documentation: "*Half-precision* vector lateral max\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32fromui32", &[SignatureDef { label: "f32fromui32 $aDst0 $aSrc0", documentation: "Unsigned integer to :term:\\'single-precision\\` floating-point conversion\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v2min", &[SignatureDef { label: "f16v2min $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector element-wise minimum\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v4sqacc", &[SignatureDef { label: "f32v4sqacc $aSrc0:Src0+3", documentation: "*Single-precision* vector accumulate squares\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("f16v4sihoslic", &[SignatureDef { label: "f16v4sihoslic $aDst0 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Half-precision* floating-point vector slim convolution\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f16v2cmplt", &[SignatureDef { label: "f16v2cmplt $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmplt $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmplt $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("not", &[SignatureDef { label: "not $aDst0 $aSrc0", documentation: "32-bit bitwise logical NOT\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("ldb16", &[SignatureDef { label: "ldb16 $aDst0 $mBase0 $mDelta0 $mOff0", documentation: "16-bit load and broadcast\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ldb16 $aDst0 $mBase0 $mDelta0 zimm12", documentation: "16-bit load and broadcast\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f32sigm", &[SignatureDef { label: "f32sigm $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32absmax", &[SignatureDef { label: "f32absmax $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point max of absolute values\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2ln", &[SignatureDef { label: "f16v2ln $aDst0 $aSrc0", documentation: "*Half-precision* floating-point vector natural logarithm\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32exp2", &[SignatureDef { label: "f32exp2 $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4absacc", &[SignatureDef { label: "f16v4absacc $aSrc0:Src0+1", documentation: "*Half-precision* vector accumulation of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("urand64", &[SignatureDef { label: "urand64 $aDst0:Dst0+1", documentation: "Uniform distribution, 64-bit random integer\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, ] }, ]),
        ("st64step", &[SignatureDef { label: "st64step $aSrc0:Src0+1 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing 64-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "st64step $aSrc0:Src0+1 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing 64-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("st32", &[SignatureDef { label: "st32 $aSrc0 $mBase0 $mDelta0 $mOffset0", documentation: "32-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOffset0", documentation: "" }, ] }, SignatureDef { label: "st32 $mSrc0 $mBase0 $mDelta0 zimm12", documentation: "32-bit store\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "st32 $aSrc0 $mBase0 $mDelta0 zimm12", documentation: "32-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("or", &[SignatureDef { label: "or $mDst0 $mSrc0 $mSrc1", documentation: "Bitwise OR\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "or $mDst0 $mSrc0 zimm12", documentation: "Bitwise OR\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "or $mDst0 $mSrc0 immz12", documentation: "Bitwise OR\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "immz12", documentation: "" }, ] }, SignatureDef { label: "or $aDst0 $aSrc0 $aSrc1", documentation: "Bitwise OR\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "or $aDst0 $aSrc0 zimm12", documentation: "Bitwise OR\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "or $aDst0 $aSrc0 immz12", documentation: "Bitwise OR\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "immz12", documentation: "" }, ] }, ]),
        ("f16v4mul", &[SignatureDef { label: "f16v4mul $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4mul $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4mul $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("sort4x32lo", &[SignatureDef { label: "sort4x32lo $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "4 x 32-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v2sub", &[SignatureDef { label: "f16v2sub $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector subtract\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2sub $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector subtract\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2sub $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector subtract\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("or64", &[SignatureDef { label: "or64 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "64-bit bitwise logical OR\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ld128", &[SignatureDef { label: "ld128 $aDst0:Dst0+3 $mBase0 $mDelta0 $mOff0", documentation: "Single 128-bit load from interleaved memory region\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+3", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ld128 $aDst0:Dst0+3 $mBase0 $mDelta0 zimm12", documentation: "Single 128-bit load from interleaved memory region\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+3", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("uput", &[SignatureDef { label: "uput zimm8 $aSrc0", documentation: "Write to an upper control register\n\n\n", parameters: &[SignatureParam { label: "zimm8", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v2cmpeq", &[SignatureDef { label: "f16v2cmpeq $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpeq $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpeq $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2min", &[SignatureDef { label: "f32v2min $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector min\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v2gina", &[SignatureDef { label: "f16v2gina $aDst0 $aSrc0 zimm12", documentation: "Get and initialise accumulators\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f16v4gacc", &[SignatureDef { label: "f16v4gacc $aDst0:Dst0+1", documentation: "Get accumulators\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, ] }, ]),
        ("mul", &[SignatureDef { label: "mul $mDst0 $mSrc0 $mSrc1", documentation: "Signed multiplication\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "mul $mDst0 $mSrc0 simm16", documentation: "Signed multiplication\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, ] }, ]),
        ("ld64step", &[SignatureDef { label: "ld64step $aDst0:Dst0+1 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing 64-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ld64step $aDst0:Dst0+1 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing 64-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("f16v2add", &[SignatureDef { label: "f16v2add $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector add\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2add $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector add\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2add $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector add\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32min", &[SignatureDef { label: "f32min $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point min\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("cmpeq", &[SignatureDef { label: "cmpeq $mDst0 $mSrc0 $mSrc1", documentation: "Equality test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "cmpeq $mDst0 $mSrc0 zimm16", documentation: "Equality test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, SignatureDef { label: "cmpeq $mDst0 $mSrc0 simm16", documentation: "Equality test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, ] }, ]),
        ("f32v2cmplt", &[SignatureDef { label: "f32v2cmplt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2cmplt $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("and", &[SignatureDef { label: "and $mDst0 $mSrc0 $mSrc1", documentation: "32-bit bitwise logical AND\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "and $mDst0 $mSrc0 zimm12", documentation: "32-bit bitwise logical AND\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "and $aDst0 $aSrc0 $aSrc1", documentation: "32-bit bitwise logical AND\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "and $aDst0 $aSrc0 zimm12", documentation: "32-bit bitwise logical AND\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "and $aDst0 $aSrc0 immz12", documentation: "32-bit bitwise logical AND\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "immz12", documentation: "" }, ] }, ]),
        ("f32v2mul", &[SignatureDef { label: "f32v2mul $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2mul $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("brpos", &[SignatureDef { label: "brpos $mSrc0 zimm19", documentation: "Branch if positive\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("f16v4maxc", &[SignatureDef { label: "f16v4maxc $aDst0 $aSrc0:Src0+1", documentation: "*Half-precision* vector 2x2 lateral max\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("f16v2exp", &[SignatureDef { label: "f16v2exp $aDst0 $aSrc0", documentation: "Natural exponential\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32v2aop", &[SignatureDef { label: "f32v2aop $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* vector accumulating outer-product\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("max", &[SignatureDef { label: "max $mDst0 $mSrc0 $mSrc1", documentation: "Maximum\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "max $mDst0 $mSrc0 zimm16", documentation: "Maximum\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, SignatureDef { label: "max $mDst0 $mSrc0 simm16", documentation: "Maximum\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, ] }, ]),
        ("ldz16step", &[SignatureDef { label: "ldz16step $mDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing zero-extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ldz16step $mDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing zero-extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("f16v4hihov4amp", &[SignatureDef { label: "f16v4hihov4amp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Half-precision* vector accumulating matrix-vector product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("ldst64pace", &[SignatureDef { label: "ldst64pace $aDst0:Dst0+1 $aSrc0:Src0+1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing 64-bit load with simultaneous 64-bit store.\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mAddr0:Addr0+1+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, SignatureParam { label: "Strimm2x2", documentation: "" }, ] }, ]),
        ("ldb16step", &[SignatureDef { label: "ldb16step $aDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing 16-bit load and broadcast\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ldb16step $aDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing 16-bit load and broadcast\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("f32sisoamp", &[SignatureDef { label: "f32sisoamp $aDst0:Dst0+1 $aSrc0 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* floating-point vector accumulating matrix-vector\nproduct\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f32v2cmpne", &[SignatureDef { label: "f32v2cmpne $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2cmpne $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("shr", &[SignatureDef { label: "shr $mDst0 $mSrc0 $mSrc1", documentation: "Logical shift right\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "shr $mDst0 $mSrc0 zimm12", documentation: "Logical shift right\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f32div", &[SignatureDef { label: "f32div $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point division\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2exp2", &[SignatureDef { label: "f16v2exp2 $aDst0 $aSrc0", documentation: "Base 2 exponential\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("uget", &[SignatureDef { label: "uget $aDst0 zimm8", documentation: "Upper control register read\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "zimm8", documentation: "" }, ] }, ]),
        ("f32v2cmpgt", &[SignatureDef { label: "f32v2cmpgt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2cmpgt $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ld128putcs", &[SignatureDef { label: "ld128putcs zimm8", documentation: "128-bit load and put to common configuration space\n\n\n", parameters: &[SignatureParam { label: "zimm8", documentation: "" }, ] }, ]),
        ("f16v4cmac", &[SignatureDef { label: "f16v4cmac $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector multiply with 2x2 lateral sum and accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v2absmax", &[SignatureDef { label: "f16v2absmax $aDst0 $aSrc1 $aSrc0", documentation: "*Half-precision* floating-point vector max of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4sisoamp", &[SignatureDef { label: "f16v4sisoamp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*f16* accumulating matrix-vector product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("ld2x64pace", &[SignatureDef { label: "ld2x64pace $aDst0:Dst0+1 $aDst1:Dst1+1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing, dual 64-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aDst1:Dst1+1", documentation: "" }, SignatureParam { label: "$mAddr0:Addr0+1+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, SignatureParam { label: "Strimm2x2", documentation: "" }, ] }, ]),
        ("f32max", &[SignatureDef { label: "f32max $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point max\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2absmax", &[SignatureDef { label: "f32v2absmax $aDst0:Dst0+1 $aSrc1:Src1+1 $aSrc0:Src0+1", documentation: "*Single-precision* vector max of absolute values\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("call", &[SignatureDef { label: "call $mDst0 zimm20", documentation: "Function call\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "zimm20", documentation: "" }, ] }, ]),
        ("ldd16v2a32", &[SignatureDef { label: "ldd16v2a32 $aDst0 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing delta-pair plus 32-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mAddr0++", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0@", documentation: "" }, ] }, ]),
        ("f16v4cmpne", &[SignatureDef { label: "f16v4cmpne $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpne $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpne $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v4istacc", &[SignatureDef { label: "f16v4istacc $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "Sort/shuffle (permute) through accumulators, with new input\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f32v2sub", &[SignatureDef { label: "f32v2sub $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector subtraction\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2sub $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector subtraction\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("brnzdec", &[SignatureDef { label: "brnzdec $mSrcDst0 zimm19", documentation: "Branch if not zero, with counter decrement\n\n\n", parameters: &[SignatureParam { label: "$mSrcDst0", documentation: "" }, SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("f16v2grand", &[SignatureDef { label: "f16v2grand $aDst0", documentation: "Gaussian distribution, 2-element *half-precision* random vector\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, ] }, ]),
        ("f16v4hihoslic", &[SignatureDef { label: "f16v4hihoslic $aDst0 $aSrc0:Src0+1 $aSrc1 enumFlags", documentation: "*Half-precision* slim convolution\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("sort4x16lo", &[SignatureDef { label: "sort4x16lo $mDst0 $mSrc0 $mSrc1", documentation: "4 x 16-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "sort4x16lo $aDst0 $aSrc0 $aSrc1", documentation: "4 x 16-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "sort4x16lo $aDst0 $aSrc0:BU $aSrc1", documentation: "4 x 16-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2absadd", &[SignatureDef { label: "f32v2absadd $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* floating-point vector add of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ldz16", &[SignatureDef { label: "ldz16 $mDst0 $mBase0 $mDelta0 $mOff0", documentation: "Zero-extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ldz16 $mDst0 $mBase0 $mDelta0 zimm12", documentation: "Zero-extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("ld64a32pace", &[SignatureDef { label: "ld64a32pace $aDst0:Dst0+1 $aDst1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing dual 64/32-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aDst1", documentation: "" }, SignatureParam { label: "$mAddr0:Addr0+1+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, SignatureParam { label: "Strimm2x2", documentation: "" }, ] }, ]),
        ("br", &[SignatureDef { label: "br $mSrc0", documentation: "Unconditional absolute branch to register target\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("roll32", &[SignatureDef { label: "roll32 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "roll32 SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("sort4x32hi", &[SignatureDef { label: "sort4x32hi $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "4 x 32-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("sub", &[SignatureDef { label: "sub $mDst0 $mSrc1 $mSrc0", documentation: "Subtraction\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, SignatureDef { label: "sub $mDst0 zimm16 $mSrc0", documentation: "Subtraction\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, SignatureDef { label: "sub $mDst0 simm16 $mSrc0", documentation: "Subtraction\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f16v8acc", &[SignatureDef { label: "f16v8acc $aSrc0:Src0+3", documentation: "*Half-precision* 8-element vector accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("not128", &[SignatureDef { label: "not128 $aDst0:Dst0+3 $aSrc0:Src0+3", documentation: "128-bit bitwise logical NOT\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+3", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("f16tof32", &[SignatureDef { label: "f16tof32 $aDst0 $aSrc0", documentation: "*f16* to *single-precision*\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32tof16", &[SignatureDef { label: "f32tof16 $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32oox", &[SignatureDef { label: "f32oox $aDst0 $aSrc0", documentation: "Floating-point reciprocal\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32mac", &[SignatureDef { label: "f32mac $aSrc0 $aSrc1", documentation: "Single precision floating-point multiply and accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("cmpult", &[SignatureDef { label: "cmpult $mDst0 $mSrc0 $mSrc1", documentation: "Unsigned less-than test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "cmpult $mDst0 $mSrc0 zimm16", documentation: "Unsigned less-than test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, ]),
        ("ld2xst64pace", &[SignatureDef { label: "ld2xst64pace $aDst0:Dst0+3 $aSrc0:Src0+1 $mAddr0:Addr0+1+= $mStride0 Strimm3x2", documentation: "Post-incrementing dual 64-bit load with simultaneous 64-bit store.\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+3", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mAddr0:Addr0+1+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, SignatureParam { label: "Strimm3x2", documentation: "" }, ] }, ]),
        ("f16v4hihoamp", &[SignatureDef { label: "f16v4hihoamp $aDst0 $aSrc0:Src0+1 $aSrc1 enumFlags", documentation: "*Half-precision* vector accumulating matrix-vector product\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f16v4sufromui", &[SignatureDef { label: "f16v4sufromui $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("ldb16b16", &[SignatureDef { label: "ldb16b16 $aDst0:Dst0+1 $mBase0 $mDelta0++ $mMiniD0&gt;&gt;", documentation: "Post-incrementing, lightly-sparse 16-bit with dense 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0++", documentation: "" }, SignatureParam { label: "$mMiniD0&gt;&gt;", documentation: "" }, ] }, ]),
        ("ld64a32", &[SignatureDef { label: "ld64a32 $aDst0+1:Dst0+3 $mAddr0++ $mBase0 $mDelta0", documentation: "Post-incrementing dense 64-bit plus sparse 32-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0+1:Dst0+3", documentation: "" }, SignatureParam { label: "$mAddr0++", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, ] }, ]),
        ("f32v2gina", &[SignatureDef { label: "f32v2gina $aDst0:Dst0+1 $aSrc0:Src0+1 zimm12", documentation: "Get and initialise accumulators\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("atom", &[SignatureDef { label: "atom $mDst0 $aSrc0", documentation: "Copy an *arf* register value to *mrf*\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4hihov4slic", &[SignatureDef { label: "f16v4hihov4slic $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Half-precision* slim convolution\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("ld64", &[SignatureDef { label: "ld64 $aDst0:Dst0+1 $mBase0 $mDelta0 $mOff0", documentation: "Single 64-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ld64 $aDst0:Dst0+1 $mBase0 $mDelta0 zimm12", documentation: "Single 64-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f16v2cmpge", &[SignatureDef { label: "f16v2cmpge $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector greater-than-or-equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpge $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector greater-than-or-equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpge $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector greater-than-or-equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32cmplt", &[SignatureDef { label: "f32cmplt $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point less than\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2sufromui", &[SignatureDef { label: "f32v2sufromui $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("roll8l", &[SignatureDef { label: "roll8l $mDst0 $mSrc0 $mSrc1", documentation: "roll8-left SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("add", &[SignatureDef { label: "add $mDst0 $mSrc0 $mSrc1", documentation: "Integer addition\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "add $mDst0 $mSrc0 zimm16", documentation: "Integer addition\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, SignatureDef { label: "add $mDst0 $mSrc0 simm16", documentation: "Integer addition\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, ] }, ]),
        ("ld64putcs", &[SignatureDef { label: "ld64putcs zimm8", documentation: "64-bit load and put to common configuration space\n\n\n", parameters: &[SignatureParam { label: "zimm8", documentation: "" }, ] }, ]),
        ("put", &[SignatureDef { label: "put zimm8 $mSrc0", documentation: "Write to a lower control register\n\n\n", parameters: &[SignatureParam { label: "zimm8", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f32class", &[SignatureDef { label: "f32class $aDst0 $aSrc0", documentation: "*Single-precision* floating-point number classifier\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v2cmpne", &[SignatureDef { label: "f16v2cmpne $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpne $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpne $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2sigm", &[SignatureDef { label: "f16v2sigm $aDst0 $aSrc0", documentation: "*Half-precision* 2-element vector logistic\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("min", &[SignatureDef { label: "min $mDst0 $mSrc0 $mSrc1", documentation: "Minimum\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "min $mDst0 $mSrc0 zimm16", documentation: "Minimum\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, SignatureDef { label: "min $mDst0 $mSrc0 simm16", documentation: "Minimum\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, ] }, ]),
        ("f16v4sum", &[SignatureDef { label: "f16v4sum $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "*Half-precision* vector 2x2 lateral summation\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("shuf8x8hi", &[SignatureDef { label: "shuf8x8hi $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("exitz", &[SignatureDef { label: "exitz $mSrc0", documentation: "Worker thread termination\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f16v4rmask", &[SignatureDef { label: "f16v4rmask $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1", documentation: "*Half-precision* vector random mask\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("st64pace", &[SignatureDef { label: "st64pace $aSrc0:Src0+1 $mAddr0:Addr0+1+= $mStride0 Strimm2", documentation: "Post-incrementing 64-bit store, using packed addresses and offsets\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mAddr0:Addr0+1+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, SignatureParam { label: "Strimm2", documentation: "" }, ] }, ]),
        ("setzi", &[SignatureDef { label: "setzi $mDst0 zimm20", documentation: "Register set from immediate\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "zimm20", documentation: "" }, ] }, SignatureDef { label: "setzi $aDst0 zimm20", documentation: "Register set from immediate\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "zimm20", documentation: "" }, ] }, ]),
        ("f32v2cmpge", &[SignatureDef { label: "f32v2cmpge $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector greater-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2cmpge $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector greater-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("exitpos", &[SignatureDef { label: "exitpos $mSrc0", documentation: "Worker thread termination\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f16v2cmpgt", &[SignatureDef { label: "f16v2cmpgt $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpgt $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpgt $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("st64", &[SignatureDef { label: "st64 $aSrc0:Src0+1 $mBase0 $mDelta0 $mOffset0", documentation: "64-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOffset0", documentation: "" }, ] }, SignatureDef { label: "st64 $aSrc0:Src0+1 $mBase0 $mDelta0 zimm12", documentation: "64-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("sort8x8hi", &[SignatureDef { label: "sort8x8hi $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("movz", &[SignatureDef { label: "movz $mSrcDst0 $mSrc0 $mSrc1", documentation: "Conditional move\n\n\n", parameters: &[SignatureParam { label: "$mSrcDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("f16v8absacc", &[SignatureDef { label: "f16v8absacc $aSrc0:Src0+3", documentation: "*Half-precision* 8-element vector accumulation of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("roll8r", &[SignatureDef { label: "roll8r $mDst0 $mSrc0 $mSrc1", documentation: "roll8-right SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("f32v2max", &[SignatureDef { label: "f32v2max $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector max\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ld32step", &[SignatureDef { label: "ld32step $mDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing *word* load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ld32step $mDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing *word* load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, SignatureDef { label: "ld32step $aDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing *word* load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ld32step $aDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing *word* load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("f32toui32", &[SignatureDef { label: "f32toui32 $aDst0 $aSrc0", documentation: "*Single-precision* floating-point to unsigned integer conversion\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32v2tof16", &[SignatureDef { label: "f32v2tof16 $aDst0 $aSrc0:Src0+1", documentation: "*Single-precision* pair to *f16* pair\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("f32v2axpy", &[SignatureDef { label: "f32v2axpy $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* 2-element vector z = ax + y\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v4mix", &[SignatureDef { label: "f16v4mix $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector z = ax + y\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ldd16a64", &[SignatureDef { label: "ldd16a64 $aDst0:Dst0+1 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing 16-bit delta and 64-bit data load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mAddr0++", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0@", documentation: "" }, ] }, ]),
        ("f16v2cmac", &[SignatureDef { label: "f16v2cmac $aSrc0 $aSrc1", documentation: "*Half-precision* vector multiply with lateral sum and accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("lds8", &[SignatureDef { label: "lds8 $mDst0 $mBase0 $mDelta0 $mOff0", documentation: "Sign extending 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "lds8 $mDst0 $mBase0 $mDelta0 zimm12", documentation: "Sign extending 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("not64", &[SignatureDef { label: "not64 $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "64-bit bitwise logical NOT\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("f32sub", &[SignatureDef { label: "f32sub $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point subtract\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32oorx", &[SignatureDef { label: "f32oorx $aDst0 $aSrc0", documentation: "Floating-point reciprocal of square-root\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4absmax", &[SignatureDef { label: "f16v4absmax $aDst0:Dst0+1 $aSrc1:Src1+1 $aSrc0:Src0+1", documentation: "*Half-precision* 4-element vector max of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("f32cmpgt", &[SignatureDef { label: "f32cmpgt $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point greater than\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("popc", &[SignatureDef { label: "popc $mDst0 $mSrc0", documentation: "Population count\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f32cmpne", &[SignatureDef { label: "f32cmpne $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point not equal\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32sqrt", &[SignatureDef { label: "f32sqrt $aDst0 $aSrc0", documentation: "Single precision square root\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("abs", &[SignatureDef { label: "abs $mDst0 $mSrc0", documentation: "Absolute value of signed 32-bit integer\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f32v4absacc", &[SignatureDef { label: "f32v4absacc $aSrc0:Src0+3", documentation: "*Single-precision* vector accumulation of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("sort4x16hi", &[SignatureDef { label: "sort4x16hi $mDst0 $mSrc0 $mSrc1", documentation: "4 x 16-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "sort4x16hi $aDst0 $aSrc0 $aSrc1", documentation: "4 x 16-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "sort4x16hi $aDst0 $aSrc0:BL $aSrc1", documentation: "4 x 16-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("brneg", &[SignatureDef { label: "brneg $mSrc0 zimm19", documentation: "Branch if negative\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("f16v2tanh", &[SignatureDef { label: "f16v2tanh $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32v2class", &[SignatureDef { label: "f32v2class $aDst0 $aSrc0:Src0+1", documentation: "*Single-precision* floating-point vector classifier\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("ld128step", &[SignatureDef { label: "ld128step $aDst0:Dst0+3 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing 128-bit load from interleaved memory region.\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+3", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ld128step $aDst0:Dst0+3 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing 128-bit load from interleaved memory region.\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+3", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("f32sisov2amp", &[SignatureDef { label: "f32sisov2amp $aDst0:Dst0+1 $aSrc0 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* floating-point vector accumulating matrix-vector\nproduct\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("cms", &[SignatureDef { label: "cms $mDst0 $mSrc0", documentation: "Count matching sign bits\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f16v4clamp", &[SignatureDef { label: "f16v4clamp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1", documentation: "*Half-precision* floating-point vector min-of-maximum\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
    ],
};
